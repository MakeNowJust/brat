include :assert
include :peg

add_results setup name: "PEG tests" {
  parses = { grammar, input, fully = true |
    parser = peg.new {
      set :rule grammar
    }

    assert parser.parse(input, null, fully) "#{input} did not parse"
  }

  doesnt_parse = { grammar, input, fully = true |
    parser = peg.new {
      set :rule grammar
    }

    assert_false parser.parse(input, null, fully) "#{input} parsed, but was not expected to"
  }

  test "string literal" {
    parses { str(:hi) } :hi
  }

  test "sequence" {
    parses { seq str(:h) str(:i) } :hi
  }

  test "many" {
    parses { many str :l } :llllll
    parses { many str :l } :l
    doesnt_parse { many str :l } :x
  }

  test "maybe" {
    parses { maybe str :h } :h
    parses { maybe str :h } :x false
  }

  test "kleene star" {
    parses { kleene str :h } :hhhhhhhhh
    parses { kleene str :h } :h
    parses { kleene str :h } :nope false
  }

  test "any" {
    parses { any str(:h) str(:i) } :h
    parses { any str(:h) str(:i) } :i
    doesnt_parse { any str(:h) str(:i) } :n false
  }

  test "regex literal" {
    parses { reg /[a-z]+\d+!\d+/ } "omgz11!111"
    doesnt_parse { reg /[a-z]+\d+!\d+/ } "#omgz11!111"
  }

  test "named rules" {
    number_parser = peg.new {
      set :number seq many(ref :digit) maybe(seq(str(".") many(ref :digit)))
      set :digit reg /[0-9]/
    }

    assert number_parser.parse("1" :number true) "Didn't parse 1"
    assert number_parser.parse("10" :number true) "Didn't parse 10"
    assert number_parser.parse("1.0" :number true) "Didin't parse 1.0"
    assert number_parser.parse("10.0" :number true) "Didin't parse 10.0"
    assert number_parser.parse("10.10" :number true) "Didin't parse 10.10"
  }

  test "simple calculator" {
    simple_calc = peg.new {
      set :exp any(ref(:paren) ref(:binary) ref(:number))
       set :number many(reg(/[0-9]/))
       set :binary seq(ref(:number) ref(:op) ref(:exp))
       set :op any(str("+") str("*") str("/") str("-"))
       set :paren seq(str("(") ref(:exp) str(")"))
    }

    assert simple_calc.parse("1-(1+1/1+2+3+(4*11))", :exp, true)
  }

  test "simple backtracking" {
    path = peg.new {
      set :a any(ref(:b) ref(:c))
       set :b seq(str(:x) ref(:d) str(:y))
       set :c seq(str(:x) ref(:d) str(:z))
       set :d any(ref(:a) and(reg //))
    }

    assert path.parse "xxxzzz", :a, true
  }
}
