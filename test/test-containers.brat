include 'assert'
setup name: "containers test" {
	test "array" {
		assert_equal 1 { x = array.new; x[0] = 1; x[0] }
		assert_equal 3 { x = [1,2,3]; x.length }
		assert_equal "a" { y = { 3}; x = [1, "a", y]; x[1] }
		assert_equal "b" { ["a" "b" "c"][1] }
		assert_equal 2 { [1,2,3,4][2 3].length }
	}

	test "large_array" {
		assert_equal :a { x = [:a, :b, :c, :d, :e, :f, :g, :h, :i, :j, :k, :l, :m, :n, :o, :p, :q, :r, :s, :t, :u, :v, :w, :x, :y, :z, :aa, :ab, :ac, :ad, :ae, :af, :ag, :ah, :ai, :aj, :ak, :al, :am, :an, :ao, :ap, :aq, :ar, :as, :at, :au, :av, :aw, :ax, :ay, :az, :ba, :bb, :bc, :bd, :be, :bf, :bg, :bh, :bi, :bj, :bk, :bl, :bm, :bn, :bo, :bp, :bq, :br, :bs, :bt, :bu, :bv, :bw, :bx, :by, :bz, :ca, :cb, :cc, :cd, :ce, :cf, :cg, :ch, :ci, :cj, :ck, :cl, :cm, :cn, :co, :cp, :cq, :cr, :cs, :ct, :cu, :cv, :cw, :cx, :cy, :cz]; x[0] }
		assert_equal :cz { x = [:a, :b, :c, :d, :e, :f, :g, :h, :i, :j, :k, :l, :m, :n, :o, :p, :q, :r, :s, :t, :u, :v, :w, :x, :y, :z, :aa, :ab, :ac, :ad, :ae, :af, :ag, :ah, :ai, :aj, :ak, :al, :am, :an, :ao, :ap, :aq, :ar, :as, :at, :au, :av, :aw, :ax, :ay, :az, :ba, :bb, :bc, :bd, :be, :bf, :bg, :bh, :bi, :bj, :bk, :bl, :bm, :bn, :bo, :bp, :bq, :br, :bs, :bt, :bu, :bv, :bw, :bx, :by, :bz, :ca, :cb, :cc, :cd, :ce, :cf, :cg, :ch, :ci, :cj, :ck, :cl, :cm, :cn, :co, :cp, :cq, :cr, :cs, :ct, :cu, :cv, :cw, :cx, :cy, :cz]; x[-1] }
	}

	test "array_indexing" {
		assert_equal "b" { b = ["a" "b" "c"]; b[1] }
		assert_equal ["a" "b" "c"] { ["z", "a", "b", "c", "d", "e", "f"][1,3] }
		assert_equal ["a" "b" "c"] { ["z", "a", "b", "c", "d", "e", "f"][-6,-4] }
		assert_equal [] { ["z", "a", "b", "c", "d", "e", "f"][10,15] }
		assert_null { [][1] }
		assert_equal ["e" "f"] { ["z", "a", "b", "c", "d", "e", "f"][10,5] }
	}

	test "array_set" {
		assert_equal "b" { a = [1,2,3]; a[1] = "b"; a[1] }
		assert_null { a = [1 2 3]; a[7] = 5; a[5] }
		assert_equal "b" { a = [1,2,3]; a[-1] = "b"; a[2] }
	}

	test "array_method" {
		assert_equal 2 { z = object.new; z.test = { [1,2,3] }; z.test[1] }
		assert_equal 1 { y = {x| x}; z = [->y]; z[0] 1 }
	}

	test "array_reverse" {
		assert_equal [1 2 3] { [3,2,1].reverse }
		assert_equal [1,2,3] { a = [1 2 3];a.reverse;a }
		assert_equal [3 2 1] { a = [1,2,3];a.reverse!;a }
	}

	test "array_concat" {
		assert_equal ["a" "b" "c" "d"] { ["a"] + ["b"] + ["c"] + ["d"] }
	}

	test "array_push" {
		assert_equal ["a" "b" "c" "d"] { ["a"] << "b" << "c" << "d" }
	}

	test "array_map" {
		assert_equal [2 3 4] { a = [1,2,3]; a.map {i| i + 1 } }
		assert_equal [] { a = []; a.map {i| i + 1 } }
	}

	test "array_map_with_index" {
		assert_equal [[0 :a],[1 :b],[2 :c]] { b = [:a :b :c]; b.map_with_index { obj, index | [index, obj] } }
		assert_equal [] { a = []; a.map_with_index {i, in | i + 1 } }
	}

	test "array_first" {
		assert_equal 1 { a = [1 2 3]; a.first }
		assert_equal 1 { [1,2,3].first }
	}

	test "array_last" {
		assert_equal 3 { a = [1,2,3]; a.last }
		assert_equal 3 { [1 2 3].last }
	}

	test "array_rest" {
		assert_equal 2 { a = [1,2,3]; a.rest.length }
		assert_equal 3 { [1 2 3].rest.rest.first }
	}

	test "array_each" {
		assert_equal [1,2,3] { b = []; [1 2 3].each { i | b << i }; b  }
		assert_equal [] { b = []; [].each { i | b << i }; b  }
	}

	test "array_each_with_index" {
		assert_equal [0 :a 1 :b 2 :c] { a = [];b = [:a, :b, :c]; b.each_with_index { obj, index | a << index << obj }; a }
		assert_equal [] { b = []; [].each_with_index { i, in | b << i }; b  }
	}

	test "array_empty" {
		assert { [].empty? }
		assert_false { [1 2].empty? }
		assert_false { a = [1,2]; a.empty? }
	}

	test "array_select" {
		assert_equal [1,2] { [1 2 3].select { i | i < 3 } }
		assert_equal [] { [].select { i | i < 3 } }
	}

	test "array_clear" {
		assert_equal [] { [1,2,3,4].clear }
	}

	test "array_delete_first" {
		assert_equal [1,2,3] { [1 2 3 4].delete_first 4; }
		assert_equal [2,3,4] { [1,2,3,4].delete_first 1 }
		assert_equal [1,2,3] { [1 2 3].delete_first 4 }
		assert_equal [1,2,3,4] { [1,1,2,3,4].delete_first 1 }
		assert_equal [1 3] { [1,2,3].delete_first 2 }
	}

	test "array_include?" {
		assert { [1,2,3].include? 3 }
		assert { a = object.new; b = [a]; b.include? a }
		assert_false { a = 1; b = [a]; b.include? 2 }
		assert_false { a = 1; b = []; b.include? 2 }
	}

	test "array_any?" {
		assert { [1,2,3].any? { x | x > 2 } }
		assert_false { [1,2,3].any? { x | x > 4 } }
		assert_false { [].any? { x | x > 4 } }
	}

	test "array_find" {
		assert_equal 3 { [1,2,3].find { x | x > 2 } }
		assert_null { [1,2,3].find { x | x > 4 } }
		assert_null { [].find { x | x > 4 } }
	}

	test "array_compare" {
		assert { [] == [] }
		assert_false { [1,2] == [3,4] }
		assert_false { [1,2,3] == [1,2] }
		assert_false { ["a", "b"] == ["b", "a"] }
	}

	test "array_sort" {
		assert_equal [1,2,3] { [3,2,1].sort }
		assert_equal [3,2,1] { a = [3,2,1]; a.sort; a }
		assert_equal ["a","b","c"] { a = ["b", "c", "a"]; a.sort }
		assert_equal ["b","c","a"] { a = ["b", "c", "a"]; a.sort; a }
	}

	test "array_sort!" {
		assert_equal [1,2,3] { [3,2,1].sort! }
		assert_equal [1,2,3] { a = [3,2,1]; a.sort!; a }
		assert_equal ["a","b","c"] { a = ["b", "c", "a"]; a.sort! }
		assert_equal ["a","b","c"] { a = ["b", "c", "a"]; a.sort!; a }
	}

	test "array_compare" {
		assert { [1,2,3] == [1,2,3] }
		assert_false { [1,3,2] == [1,2,3] }
		assert { a = ["a"]; b = ["a"]; a == b }
		assert_false { a = ["a"]; b = ["b"]; a == b }
		assert_false { a = ["a"]; b = ["b", "c"]; a == b }
		assert { a = object.new; b = object.new; c = [a,b]; d = [a,b]; c == d }
	}

	test "array_join" {
		assert_equal "a, b, c" { ["a", "b", "c"].join ", " }
		assert_equal "1, 2, 3" { [1, 2, 3].join ", " }
	}

	test "hash" {
		assert_equal 1 { x = hash.new; x["y"] = 1; x["y"] }
		assert_equal 1 { x = [:]; x["y"] = 1; x["y"] }
		assert_equal 1 { x = [ : ]; x["y"] = 1; x["y"] }
		assert_equal 0 { x = [:]; x.length }
		assert_equal "a" { x = [1:"a"]; x[1]; }
		assert_equal 2 { y = [2]; x = [1:y]; x[1][0] }
		assert_equal "a" { x = [b:"a"]; x[:b]; }
		assert_equal :a { x = [b::a]; x[:b]; }
	}

	test "hash_literal" {
		assert_equal [:] { [:] }
		assert_equal [a: :b] { [a: :b] }
	}

	test "hash_key?" {
		assert { a = ["a" : 1]; a.key? "a" }
		assert_false { a = ["a" : 1]; a.key? 1 }
		assert_false { a = [1:"hi"]; a.key? "1" }
	}

	test "hash_each" {
		assert { a = ["a" : 1 "b" : 2, 3 : 4]; b = []; a.each { key, val | b << val << key }; b.length == 6 && (b.include? "b") && (b.include? 2) && (b.include? 4) }
	}

	test "hash_each_key" {
		assert { a = ["a" : 1 "b" : 2, 3 : 4]; b = []; a.each_key { key | b << key }; b.length == 3 && (b.include? 3) && (b.include? "a") && (b.include? "b") }
	}

	test "hash_each_value" {
		assert { a = ["a" : 1, "b" : 2 3 : 4]; b = []; a.each_value { val | b << val }; b.length == 3 && (b.include? 4) && (b.include? 2) && (b.include? 1) }
	}

	test "hash_map" {
		assert { a = ["a" : 1, "b" : 2, 3 : 4]; b = []; b = a.map { key, val | val}; b.length == 3 && (b.include? 4) && (b.include? 2) && (b.include? 1) }
	}

	test "hash_delete" {
		assert_false { a = ["a" : 1, "b" : 2, 3 : 4]; a.delete "a"; a.key? "a" }
	}

	test "hash_length" {
		assert_equal 3 { a = ["a" : 1 "b" : 2 3 : 4]; a.length }
	}

	test "hash_select" {
		assert { a = ["a" : 1 "b" : 2 3 : 4]; b = a.select { key, val | val > 1 }; b.key?("b") && (b.length == 2) }
	}

	test "hash_keys" {
		assert { a = ["a" : 1 "b" : 2 3 : 4]; a.keys.include?("a") && (a.keys.length == 3) }
	}

	test "hash_plus" {
		assert_equal 3 { 
				a = [a: 1
					b: 2
					c: 3]
				b = [
					b:3
					d:4
				]
				c = a + b; c[:b] }
		assert_equal 4 { a = [a: 1, b: 2, c: 3]; b = [b:3, d:4]; c = a + b; c.length }
	}

	test "hash_empty?" {
		assert_false { a = ["a" : 1, "b" : 2, 3 : 4]; a.empty? }
		assert { a = ["a" : 1 "b" : 2 3 : 4]; b = a.select {k,v| v == 5 }; b.empty? }
	}

	test "hash vs. array parsing" {
		assert_equal [0, :1] { [0 :1] }
		assert_equal :a { a = :a; [0:a][0] }
		assert_equal :a { [0 :a][1] }
		assert_equal :a { b = :a; [0: b][0] }
		assert_equal :a { b = :a; [0 : b][0] }
		assert_equal :a { [:a :a].first }
		assert_equal :a { ([1 :a] + [2 :a])[1] }
		assert_equal :a { array.! = array->first; ![:a :b] }
	}
}
