#!/bin/env ruby

def compile_parser force = false
	if force or not File.exist? "#$program_path/parser/brat.rb" or newer? "#$program_path/parser/brat.treetop", "#$program_path/parser/brat.rb"
		system "cd #$program_path/parser && tt brat.treetop"
	else
		false
	end
end

def compile_brat_internal force = false
	if force or not File.exist? "#$program_path/core/internal.n" or newer? "#$program_path/core/internal.neko", "#$program_path/core/internal.n"
		system "cd #$program_path/core && nekoc internal.neko"
	else
		false
	end
end

def compile_core force = false
	if force or not File.exist? "#$program_path/core/core.n" or newer? "#$program_path/core/core.brat", "#$program_path/core/core.n"
		require 'rubygems'
		require 'treetop'
		require "#$program_path/parser/brat"
		require "#$program_path/parser/parser-extension"

		File.open "#$program_path/core/core.brat.neko", "w" do |f|
			f.puts BaseBratParser.new.parse(File.read("#$program_path/core/core.brat")).core_brat
		end

		system "nekoc #$program_path/core/core.brat.neko" or abort "Error while compiling program"
		system "mv #$program_path/core/core.brat.n #$program_path/core/core.n"
	else
		false
	end
end

def brat_to_neko input
	require 'rubygems'
	require 'treetop'
	require "#$program_path/parser/brat"
	require "#$program_path/parser/parser-extension"

	parser = BaseBratParser.new
	tree = parser.parse(input)
	if tree.nil? or not tree.respond_to? :brat
		raise "Error during parsing:\n#{parser.terminal_failures.join("\n")}\n#{tree.inspect}"
	else
		tree.brat
	end
end

def newer? file1, file2
	File.mtime(file1) > File.mtime(file2)
end

def brat file_name, keep_intermediate = false, force = false
	new_parser = compile_parser(force)
	new_internal =compile_brat_internal(force) 
	new_core = compile_core(force)
	force = force || new_parser || new_internal || new_core

	if not File.exist?(file_name + ".n") or newer? file_name, file_name + ".n" or force
		if not File.exist? file_name + ".neko" or newer? file_name, file_name + ".neko" or force
			brat_input = File.read file_name
			begin
				neko = brat_to_neko brat_input
			rescue RuntimeError => e
				puts e
				exit
			end
			File.open(file_name + ".neko", "w") {|f| f.puts neko }
		end

		system "nekoc #{file_name}.neko" or abort "Error while compiling program"
	end

	if not keep_intermediate and File.exist? file_name + ".neko"
		File.delete file_name + ".neko"
	end

	if not system "neko #{file_name}.n"
		abort "Error while running program."
	end
end

def output_brat
	puts brat_stdin.gsub(/^var ([^@]([^;\s])*)/, '\1')
end

def brat_stdin
	input = ""
	loop do
		line = $stdin.gets
		if line.nil?
			break
		else
			input << line
		end
	end
	
	require 'rubygems'
	require 'treetop'
	require "#$program_path/parser/brat"
	require "#$program_path/parser/parser-extension"

	parser = BaseBratParser.new
	tree = parser.parse(input)
	if tree.nil? or not tree.respond_to? :brat
		raise "Error during parsing:\n#{parser.terminal_failures.join("\n")}\n#{tree.inspect}"
	else
		tree.inner_brat
	end
end

def brat_interactive
	brat_console = IO.popen "#$program_path/bin/neko_console", "r+"
	brat_console.gets

	current = 0
	prompt = ">"
	line = ""
	loop do
		current += 1
		print "#{current}#{prompt} "
		line << $stdin.gets

		stripped = line.strip

		if stripped.empty?
			next
		elsif not line_closed? line
			prompt = "?"
			next
		elsif stripped == "quit" or stripped == "exit"
			brat_console.print "!quit\n\1"
			exit
		end

		neko = `echo '#{line}' | ruby #{$program_path}/brat -z`

		brat_console.print neko
		brat_console.print "\1"

		begin
			loop do
				response = brat_console.read_nonblock(12024)
				print response.gsub("\1", "")
				break if response.include? "\1" or response.nil?
			end
		rescue Errno::EAGAIN
			retry
		rescue Exception => e
			p e
		end	       


		prompt = ">"
		line = ""
	end
end

def line_closed? line
	
	items = line.scan(/\{|\}|"|\/|\(|\)|\[|\]/)

	count = Hash.new(0)
	items.each do |i|
		count[i] += 1
	end

	if not count['"'].even? or not count["/"].even? or count["{"] != count["}"] or count["("] != count[")"] or count["["] != count["]"]
		false
	else
		true
	end
end

def show_help
	puts <<-END
Usage: brat [options] [file_name]
Possible options:
-a    Force recompilation of parser
-f    Ignore existing .n file
-h    Show this help
-i    Interactive Brat
-k    Don't erase intermediate files
-s    Create standalone executable
-t    Benchmark code
-z    Read Brat code from standard input and emit Neko code
	END
end


if ARGV[0]
	$program_path = File.dirname(File.expand_path(__FILE__))

	ENV['LD_LIBRARY_PATH'] ||= "" 
	ENV['LD_LIBRARY_PATH'] = ENV['LD_LIBRARY_PATH'] + ":#$program_path/lib/"
	ENV['NEKOPATH'] ||= ""
	ENV['NEKOPATH'] = ENV['NEKOPATH'] + ":#$program_path/lib/:#$program_path/core/"
	ENV['PATH'] ||= ""
	ENV['PATH'] = ENV['PATH'] + ":#$program_path/bin/"

	require 'set'
	options = Set.new(ARGV)

	if options.include? '-h'
		show_help
		exit
	elsif options.include? '-z'
		output_brat
		exit
	elsif options.include? '-i'
		brat_interactive

	end

	file_name = Dir.pwd + "/" + ARGV[-1]

	if not File.exist? file_name
		abort "No such file: #{ARGV[-1]}"
	end



	force = options.include? "-a"
	keep_intermediate = options.include? "-k"

	if options.include? '-f'
		File.delete(file_name + ".n") rescue nil
	end

	if options.include? "-s"
		brat_standalone file_name, keep_intermediate, force
	elsif options.include? "-t"
		require 'benchmark'
		time = Benchmark.measure do
			brat file_name, keep_intermediate, force
		end
		puts "Ran in: #{time.format('%r')} seconds"
	else
		brat file_name, keep_intermediate, force
	end

else
	abort "Please supply Brat file name"
end
