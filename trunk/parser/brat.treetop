grammar BaseBrat

  rule program
 	line+ {
		def brat
			"var @brat = $loader.loadmodule(\"neko/internal\", $loader);\n" <<
			"@brat.base_object.@main_tantrum = function() {\n" <<
			"var array = @brat.base_array;" <<
			"var hash = @brat.base_hash;" <<
			"var number = @brat.base_number;" <<
			"var string = @brat.base_string;" <<
			"var regex = @brat.base_regex;" <<
			"\n" <<
			self.inner_brat << ";\n" <<
			"}\n" <<
			"@exit_value = @brat.base_object.@main_tantrum();\n"
		end

		def inner_brat
			elements.map {|e| "   " << e.brat if e.respond_to? :brat }.compact.join(";").gsub(";", ";\n")
		end
	}
	/
	eof
  end

  rule line
	~comment 
	/
 	~(space?) e:expression ~(space?) ~(comment?) ~( eof / eol / eob)  {
		def brat
			if e.respond_to? :no_result_brat
				e.no_result_brat
			elsif e.respond_to? :brat
				e.brat
			end
		end
	}
	/
	~empty_line
  end

  rule empty_line
  	space? ~eol {
		def brat
			""
		end
	}
  end

  rule expression
	unary_operation / binary_operation / index_set / index_get /
	assignment / paren_exp ~(!".") { def brat; output = paren_exp.brat; @result = paren_exp.result; output;  end } / 
	method_access / method_invocation / number / string / method_definition / hash / array / regex
  end

  rule expression2
 	hash / array / paren_exp / method_invocation / string
  end

  rule expression3
 	hash / array / paren_exp / number / string / regex
  end

  rule expression4
 	index_get / paren_exp / number / string / hash / bare_array / method_invocation2 / regex
  end

  rule regex
	"/" r:(!"/" . / "\\/")* "/" {
		def brat
			next_temp
			"var #@result = regex.new(\"#{r.text_value}\")"
		end
	}
  end

  rule comment
	space? ("//" / "#") (!(eol/eof) .)+ {
		def brat
			""
		end
	}
	/
	space? "/*" (!"*/" .)+ "*/"
  end

  rule hash
  	"[" spaceorbreak hash_inner spaceorbreak "]" {
		def brat
			output = hash_inner.brat
			@result = hash_inner.result
			output
		end
	}
  end

  rule array
  	"[" spaceorbreak inner_arg_list spaceorbreak "]" {
		def brat
			output = inner_arg_list.brat
			next_temp
			output << "var #@result = @brat.make_array(#{inner_arg_list.array});"
		end
	}
	/
	"[" spaceorbreak "]" {
		def brat
			next_temp
			"var #@result = @brat.make_array($amake(0));"
		end
	}
  end

  rule bare_array
  	"[" spaceorbreak inner_arg_list spaceorbreak "]" ~(&(space / eol)) {
		def brat
			output = inner_arg_list.brat
			next_temp
			output << "var #@result = @brat.make_array(#{inner_arg_list.array});"
		end
	}
  end

  rule hash_inner
	first:hash_argument rest:(spaceorbreak "," spaceorbreak n:hash_argument spaceorbreak)* {
		def brat
			next_temp
			hash_temp = @result
			output = "var #{hash_temp} = $hnew(#{rest.elements.length + 1});"
			output << first.brat
			output << "@brat.hset(#{hash_temp}, #{first.index}, #{first.value});"
			rest.elements.each do |e|
				elem = e.n
				output << elem.brat
				output << "@brat.hset(#{hash_temp}, #{elem.index}, #{elem.value});"
			end
			next_temp
			output << "var #@result = @brat.make_hash(#{hash_temp});"
		end
	}

  end

  rule hash_argument
  	i:expression spaceorbreak ":" spaceorbreak v:expression {
		attr_reader :index, :value
		def brat
			output = i.brat
			output << v.brat
			@index = i.result
			@value = v.result
			output
		end
	}
  end

  rule index_set
  	a:expression2 "[" i:expression "]" space? "=" spaceorbreak v:expression {
		def brat
			output = a.brat
			output << i.brat
			output << v.brat
			next_temp
			output << "var #@result = #{a.result}.__set(#{i.result}, #{v.result});"
		end
	}
  end

  rule index_get
  	e:expression2 a:("[" inner_arg_list "]")+ !"." args:arg_list {

		def brat
			output = e.brat
			last = e.result
			a.elements.each do |elem|
				output << elem.inner_arg_list.brat
				next_temp
				output << "var #@result = #{last}.__get(#{elem.inner_arg_list.list});" 
				last = @result
			end
			unless args.respond_to? :nothing?
				output << args.brat
				next_temp
				output << "var #@result = " << invoke(last, args.list, args.length) << ";"
			end
			output
		end
	}
  end

  rule assignment
 	lhs:field_access space? "=" spaceorbreak rhs:method_definition {
		def brat
			output = lhs.brat <<
			rhs.brat  <<
			"$objset(#{lhs.result}, $hash(\"#{lhs.i.brat}\"), #{rhs.result});"
			@result = rhs.result
			output
		end
	}
	/
 	lhs:field_access space? "=" spaceorbreak rhs:method_access {
		def brat
			output = lhs.brat << 
			rhs.brat <<
			"$objset(#{lhs.result}, $hash(\"#{lhs.i.brat}\"), #{rhs.result});"
			@result = rhs.result
			output
		end
	}
	/
 	lhs:field_access space? "=" spaceorbreak rhs:expression {
		def brat
			output = lhs.brat << 
			rhs.brat <<
			"$objset(#{lhs.result}, $hash(\"#{lhs.i.brat}\"), function() {#{rhs.result}});"
			@result = rhs.result
			output
		end
	}
	/
	lhs:identifier space? "=" spaceorbreak rhs:expression {
		def brat
			output = rhs.brat <<
			if var_exist? lhs.brat
				"#{lhs.brat} = #{rhs.result};"
			else
				var_add lhs.brat
				"var #{lhs.brat} = #{rhs.result};"
			end
			@result = rhs.result
			output
		end
	}
  end

  rule field_access
  	m:method_chain i:(identifier / operator) {
		def brat
			output = m.brat
			@result = m.result
			output
		end
	}
  end

  rule paren_exp
  	'(' expression ')' {
		def brat
			output = expression.brat
			@result = expression.result
			output
		end
	}
  end

  rule identifier
	
	[a-zA-Z] (!"->" !space [a-zA-Z0-9_!?\-*+^&@~/\\><$_%])* {
		def brat
			text_value.gsub(/([!?\-*+^&@~\/\\><$_%])/) do |e|
				case $1
				when "!"	
					"@bang"
				when "*"
					"@star"
				when "-"
					"@minus"
				when "+"
					"@plus"
				when "&"
					"@and"
				when "@"
					"@at"
				when "~"
					"@tilde"
				when "^"
					"@up"
				when "/"
					"@forward"
				when "\\"
					"@back"
				when "?"
					"@question"
				when "<"
					"@less"
				when ">"
					"@greater"
				when "$"
					"@dollar"
				when "_"
					"@under"
				when "%"
					"@percent"
				else
					nil	
				end
			end.gsub(/(true|false|if|then|else|do|while|break|continue|switch|default|null|var|try|catch|return|function|this)/i) {|m| "@" + $1 }

		end
	}
  end

  rule number
  	float / integer 
  end

  rule float
  	i:integer "." d:integer {
		def brat
			next_temp
			"var #@result = number.new(#{i.text_value}.#{d.text_value});"
		end
	}
  end

  rule integer
	[0-9]+ {
		def brat
			next_temp
			"var #@result = number.new(#{text_value});"
		end
	}
  end

  rule string
    '"' (!'"' . / '\"')* '"' {
	    def brat
		    next_temp
		    "var #@result = string.new(#{text_value});"
	    end
    }
  end

  rule method_definition
	"{" space? fa:formal_args space? l:line* space? "}" {
		def brat
			new_scope
			if fa.respond_to? :brat
				args = fa.brat
			else
				args = ""
			end
			next_temp
			output = "var #@result = function(#{args}) { #{l.elements.map {|e| e.brat}.join(";")} };"
			pop_scope
			output
		end
	}
  end

  rule formal_args
  	"|" space? i:identifier? rest_formal "|" {
		def brat
			if i.respond_to? :brat
				var_add i.brat
				args = [i.brat] + rest_formal.brat
			else
				args = []
			end.join(", ")
		end
	}
	/
	!"|" 
  end

  rule rest_formal
  	(space? "," space? identifier)* {
		def brat
			if elements.length > 0
				elements.map do |e|
					var_add e.identifier.brat
					e.identifier.brat
				end
			else
				[]
			end
		end
	}
  end

  rule unary_operation
	op:operator !space rhs:expression {
		def brat
			next_temp
			rhs.brat <<
			"var #@result = " << call_method(rhs.result, op.brat) << ";"
		end
	}
  end

  rule binary_operation
	lhs:binary_operation_chain rhs:expression
	 {
		def brat
			output = lhs.brat
			output << rhs.brat
			next_temp
			output << "var #@result = " << call_method(lhs.result, lhs.last_operator, "$array(#{rhs.result})") << ";"
		end
	}
  end

  rule binary_operation_chain
	(e:expression4 ~space op:operator ~space)+ {
		attr_reader :last_operator
		def brat
			first = elements.shift
			output = first.e.brat
			last = first.e.result
			@result = last
			last_operator = first.op.brat

			elements.each do |elem|
				output << elem.e.brat
				next_temp
				output << "var #@result = " << call_method(last, last_operator, "$array(#{elem.e.result})") << ";"
				last = @result
				last_operator = elem.op.brat
			end

			@last_operator = last_operator
			output
		end
	}
  end

  rule method_invocation2
  	lhs:method_chain i:(identifier / operator) a:simple_arg_list {
		def brat
			output = lhs.brat
			output << a.brat
			next_temp
			output << "var #@result = " << call_method(lhs.result, i.brat, a.array) << ";"
		end
	}
	/
	m:identifier a:simple_arg_list {
		def brat
			next_temp
			name = m.brat
			a.brat <<
			"var #@result = " << get_value(name, a.array) << ";"
		end
	}/
	m:paren_exp a:simple_arg_list {
		def brat
			output = m.brat
			output << a.brat
			next_temp
			output << "var #@result = " << invoke(m.result, a.list, a.length) << ";"
		end
	}

  end


  rule method_invocation
  	lhs:method_chain i:(identifier / operator) a:arg_list {
		def brat
			output = lhs.brat
			output << a.brat
			next_temp
			output << "var #@result = " << call_method(lhs.result, i.brat, a.array) << ";"
		end

		#if lhs refers to 'this', we can just call it as though
		#there were no lhs, possibly doing tail-recursion optimization
		def no_result_brat
			return self.brat
			output = lhs.brat
			output << a.brat
			next_temp
			output <<
			"if(this == #{lhs.result}) {" << 
				get_value_clean(i.brat, a.list, a.length) << 
			"} else {" <<
				call_method(lhs.result, i.brat, a.array) << 
			"};"
		end

	}
	/
	m:identifier a:arg_list {
		def brat
			next_temp
			name = m.brat
			a.brat <<
			"var #@result = " << get_value(name, a.array) << ";"
		end

		def no_result_brat
			next_temp
			name = m.brat
			a.brat <<
			get_value_clean(name, a.list, a.length) << ";"
		end
	}
	/
	m:paren_exp a:arg_list {
		def brat
			output = m.brat
			output << a.brat
			next_temp
			output << "var #@result = " << invoke(m.result, a.list, a.length) << ";"
		end
	}
  end

  rule method_chain
 	(e:method_lhs ".")+ {
		def brat
			output = elements.first.e.brat
			last = elements.first.e.result
			@result = last
			meth = args = nil
			elements[1..-1].each do |elem|
				meth = elem.e.identifier.brat
				args = elem.e.arg_list
				output << args.brat
				next_temp
				output << "var #@result = " << call_method(last, meth, args.array) << ";"
				last = @result
			end
			output
		end
	}
	
  end

  rule method_lhs
  	identifier !space arg_list a:("[" inner_arg_list "]")* {
		def brat
			next_temp
			output = arg_list.brat
			name = identifier.brat
			output <<
			"var #@result;//exceellent\n" <<
			"if(@brat.has_field(this, \"#{name}\")) {" <<
			" #@result = " << call_method("this", name, arg_list.array) <<
			"}" <<
			"else " <<
			" if($typeof(#{name}) == $tfunction) {" <<
			" #@result = " << invoke(name, arg_list.list, arg_list.length) << ";" <<
			" } else if($typeof(#{name}) == $tobject) { " <<
			"  #@result = #{name}}" <<
			"else { $throw \"Tried to invoke method on #{name}\" };"
			last = @result
			if not a.elements.empty?
				a.elements.each do |elem|
					output << elem.inner_arg_list.brat
					next_temp
					output << "var #@result = #{last}.__get(#{elem.inner_arg_list.list});"
					last = @result
				end
			end
			output
		end	
	}
	/
	a:array a_rest:(array+) {
		def brat
			output = a.brat
			last = a.result
			a_rest.elements.each do |elem|
				output << elem.inner_arg_list.brat
				next_temp
				output << "var #@result = #{last}.__get(#{elem.inner_arg_list.list});"
				last = @result
			end
			@result = last
			output
		end
	}
	/
	expression3
  end

  rule method_access
  	"->" m:(identifier / operator) {
		def brat
			next_temp
			name = m.brat
			if var_exist? name
				"var #@result = #{name};"
			else	
				"var #@result = $objget(this, $hash(\"#{name}\"));"
			end
		end
	}
	/
  	o:method_invocation "->" m:identifier {
		def brat
			next_temp
			o.brat <<
			"var #@result = $objget(#{o.result}, $hash(\"#{m.brat}\"));"
		end
	}
  end

  rule arg_list
	'(' inner_arg_list ')' {
		def brat
			inner_arg_list.brat
		end

		def array
			inner_arg_list.array
		end

		def length
			inner_arg_list.length
		end

		def list
			inner_arg_list.list
		end
	}
	/
	'(' empty_list ')' {
		def brat
			""
		end

		def array
			"$amake(0)"
		end

		def length
			0
		end

		def list
			""
		end
	}
	/
  	space inner_arg_list {
		def brat
			inner_arg_list.brat
		end

		def array
			inner_arg_list.array
		end

		def length
			inner_arg_list.length
		end

		def list
			inner_arg_list.list
		end

	}
	/
	![(] ~(&(space?)) {
		def brat
			""
		end

		def array
			"$amake(0)"
		end

		def length
			0
		end

		def list
			""
		end

		def nothing?
			true
		end
	}
  end

  rule simple_arg_list
	'(' inner_arg_list ')' {
		def brat
			inner_arg_list.brat
		end

		def array
			inner_arg_list.array
		end

		def length
			inner_arg_list.length
		end

		def list
			inner_arg_list.list
		end
	}
	/
	'(' empty_list ')' {
		def brat
			""
		end

		def array
			"$amake(0)"
		end

		def length
			0
		end

		def list
			""
		end
	}
	/
	![(] &(space) {
		def brat
			""
		end

		def array
			"$amake(0)"
		end

		def length
			0
		end

		def list
			""
		end

		def nothing?
			true
		end
	}
  end


  rule inner_arg_list
  	e:arg_first o:arg_next* {
		attr_reader :length, :list
		def brat
			output = ""
			args = []
			named_args = []

			if e.respond_to? :named_argument?
				output << e.brat
				named_args << e
			else
				output << e.brat
				args << e.result
			end

			o.elements.each do |elem|
				if elem.respond_to? :brat
					if elem.arg_first.respond_to? :named_argument?
						output << elem.arg_first.brat
						named_args << elem.arg_first
					else
						output << elem.brat
						args << elem.result
					end
				end
			end
			unless named_args.empty?
				next_temp
				hash_temp = @result
				output << "var #{hash_temp} = $hnew(#{named_args.length});"
				named_args.map do |e|
					output << e.i.brat
					output << "@brat.hset(#{hash_temp}, #{e.i.result}, #{e.result});"
				end
				next_temp
				output << "var #@result = @brat.make_hash(#{hash_temp});"
				args << @result
			end

			@list = args.join(',')
			@length = args.length
			output
		end

		def array
			if length > 0
				"$array(#{self.list})"
			else
				"$amake(0)"
			end
		end
	}
  end

  rule arg_first
	named_argument / expression
  end

  rule arg_next
  	~((space / eol)*) "," ~((space / eol)*) arg_first {
		def brat
			output = arg_first.brat
			@result = arg_first.result
			output
		end
	}
  end

  rule named_argument
  	i:expression spaceorbreak ":" spaceorbreak e:expression {
		def brat
			output = e.brat
			@result = e.result
			output
		end

		def named_argument?
			true
		end
	}
  end

  rule operator
	!("->" !operator) ("!=" / ">=" / "<=" / [!?\-*+^@~/\\><$_%] / "||" / "|" / "&&" / "&" / "==" )+ {
		def brat
			elements.map {|e| e.text_value}.join.gsub(/(!=|>=|<=|[!?\-*+^@~\/\\><$_%|&]|==)/) do
			case $1
			when "!"	
				"@bang"
			when "*"
				"@star"
			when "-"
				"@minus"
			when "+"
				"@plus"
			when "||"
				"@oror"
			when "|"
				"@or"
			when "&&"
				"@andand"
			when "&"
				"@and"
			when "@"
				"@at"
			when "~"
				"@tilde"
			when "^"
				"@up"
			when "/"
				"@forward"
			when "\\"
				"@back"
			when "?"
				"@question"
			when "<"
				"@less"
			when ">"
				"@greater"
			when "!="
				"@notequal"
			when "=="
				"@equal"
			when ">="
				"@greater@equal"
			when "<="
				"@less@equal"
			when "%"
				"@percent"
			else
				"---something unmatched---"
			end
		end
	end
	}
  end

  rule empty_list
  	~(space?)
  end

  rule eol
	("\n" / ";" / "\r\n")+ {
		def brat
			"\n"
		end
	}
  end

  rule space
     (" " / "\t")+ {
		def brat
			text_value
		end
	}
  end
  
  rule eof
  	~((eol / space)? !.)
  end

  rule eob
  	~(space? &"}" space?)
  end

  rule spaceorbreak
	space? eol? space?
  end
end
