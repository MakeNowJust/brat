grammar BaseBrat

  rule program
 	line+ {
		def brat
			"var @brat = $loader.loadmodule(\"neko/internal\", $loader);\n" <<
			"var @main_brat  = $new(@brat.base_object);\n" <<
			"@main_brat.@main_tantrum = function() {\n" <<
			"var array = $new(@brat.base_array);" <<
			"var hash = $new(@brat.base_hash);" <<
			self.inner_brat << ";\n" <<
			"}\n" <<
			"@exit_value = @main_brat.@main_tantrum();\n"
		end

		def inner_brat
			elements.map {|e| e.brat }.compact.join(";").gsub(";", ";\n")
		end
	}
	/
	eof
  end

  rule line
 	space? e:expression space? ( eof / eol / eob) {
		def brat
			e.brat if e.respond_to? :brat
		end
	}
	/
	empty_line
  end

  rule empty_line
  	space? eol {
		def brat
			""
		end
	}
	/
	space
  end

  rule expression
 	index_set / index_get / assignment / paren_exp / method_access / method_invocation / number / string / method_definition / hash / array 
  end

  rule expression2
 	hash / array / paren_exp / method_invocation / string
  end

  rule expression3
 	hash / array / paren_exp / number / string
  end

  rule hash
  	"[" hash_inner "]" {
		def brat
			output = hash_inner.brat
			@result = hash_inner.result
			output
		end
	}
  end

  rule array
  	"[" inner_arg_list "]" {
		def brat
			output = inner_arg_list.brat
			next_temp
			output << "var #@result = @brat.make_array(#{inner_arg_list.result});"
		end
	}
  end

  rule hash_inner
	first:hash_argument rest:(space? "," space? n:hash_argument)* {
		def brat
			next_temp
			hash_temp = @result
			output = "var #{hash_temp} = $hnew(#{rest.elements.length + 1});"
			output << first.brat
			output << "$hset(#{hash_temp}, #{first.index}, #{first.value}, null);"
			rest.elements.each do |e|
				elem = e.n
				output << elem.brat
				output << "$hset(#{hash_temp}, #{elem.index}, #{elem.value}, null);"
			end
			next_temp
			output << "var #@result = @brat.make_hash(#{hash_temp});"
		end
	}

  end

  rule hash_argument
  	i:expression space? ":" space? v:expression {
		attr_reader :index, :value
		def brat
			output = i.brat
			output << v.brat
			@index = i.result
			@value = v.result
			output
		end
	}
  end

  rule index_set
  	a:expression2 "[" i:expression "]" space? "=" space? v:expression {
		def brat
			output = a.brat
			output << i.brat
			output << v.brat
			next_temp
			args = @result
			output << "var #{args} = $array(#{i.result}, #{v.result});"
			next_temp
			output << "var #@result = @brat.call_method(#{a.result}, \"__set\", #{args});"
		end
	}
  end

  rule index_get
  	e:expression2 a:("[" inner_arg_list "]")+ args:arg_list {

		def brat
			output = e.brat
			last = e.result
			a.elements.each do |elem|
				output << elem.inner_arg_list.brat
				next_temp
				output << "var #@result = @brat.call_method(#{last}, \"__get\", #{elem.inner_arg_list.result});" 
				last = @result
			end
			unless args.respond_to? :nothing?
				output << args.brat
				next_temp
				output << "var #@result = @brat.invoke(#{last}, #{args.result});"
			end
			output
		end
	}
  end

  rule assignment
 	lhs:field_access space? "=" space? rhs:method_definition {
		def brat
			output = lhs.brat <<
			rhs.brat(lhs.result) <<
			"$objset(#{lhs.result}, $hash(\"#{lhs.i.brat}\"), #{rhs.result});"
			@result = rhs.result
			output
		end
	}
	/
 	lhs:field_access space? "=" space? rhs:method_access {
		def brat
			output = lhs.brat << 
			rhs.brat <<
			"$objset(#{lhs.result}, $hash(\"#{lhs.i.brat}\"), #{rhs.result});"
			@result = rhs.result
			output
		end
	}
	/
 	lhs:field_access space? "=" space? rhs:expression {
		def brat
			output = lhs.brat << 
			rhs.brat <<
			"$objset(#{lhs.result}, $hash(\"#{lhs.i.brat}\"), function() {#{rhs.result}});"
			@result = rhs.result
			output
		end
	}
	/
	lhs:identifier space? "=" space? rhs:expression {
		def brat
			output = rhs.brat <<
			if var_exist? lhs.brat
				"#{lhs.brat} = #{rhs.result}"
			else
				var_add lhs.brat
				"var #{lhs.brat} = #{rhs.result}"
			end
			@result = rhs.result
			output
		end
	}
  end

  rule field_access
  	m:method_chain i:identifier {
		def brat
			output = m.brat
			@result = m.result
			output
		end
	}
  end

  rule paren_exp
  	'(' expression ')' {
		attr_reader :result
		def brat
			next_temp
			"var #@result = (" + expression.brat + ");"
		end
	}
  end

  rule identifier
  	[a-zA-Z] [a-zA-Z0-9_!?]* {
		def brat
			text_value
		end
	}
  end

  rule number
  	float / integer 
  end

  rule float
  	i:integer "." d:integer {
		def brat
			next_temp
			"var #@result = #{i.text_value}.#{d.text_value};"
		end
	}
  end

  rule integer
	[0-9]+ {
		def brat
			next_temp
			"var #@result = #{text_value};"
		end
	}
  end

  rule digit
  	[0-9] {
		def brat
			text_value
		end
	}
  end

  rule string
    '"' (!'"' . / '\"')* '"' {
	    def brat
		    next_temp
		    "var #@result = #{text_value};"
	    end
    }
  end

  rule method_definition
	"{" space? fa:formal_args space? l:line* "}" {
		def brat(this = "this")
			new_scope
			if fa.respond_to? :brat
				args = fa.brat
			else
				args = ""
			end
			next_temp
			output = "var #@result = function(#{args}) { this = #{this}; #{l.elements.map {|e| e.brat}.join(";")} };"
			pop_scope
			output
		end
	}
  end

  rule formal_args
  	"|" space? i:identifier? rest_formal "|" {
		def brat
			if i.respond_to? :brat
				args = [i.brat] + rest_formal.brat
			else
				args = []
			end.join(", ")
		end
	}
	/
	!"|" 
  end

  rule rest_formal
  	(space? "," space? identifier)* {
		def brat
			if elements.length > 0
				elements.map do |e|
					e.identifier.brat
				end
			else
				[]
			end
		end
	}
  end

  rule method_invocation
  	lhs:method_chain i:identifier a:arg_list {
		def brat
			output = lhs.brat
			output << a.brat
			next_temp
			output << "var #@result = @brat.call_method(#{lhs.result}, \"#{i.brat}\", #{a.result});"
		end
	}
	/
	m:identifier a:arg_list {
		def brat
			next_temp
			a.brat <<
			"var #@result;
			//being called as (identifier arg_list)
			if($typeof(#{m.brat}) == $tnull) {
				if(@brat.has_field(this, \"#{m.brat}\")) {
			 		#@result = @brat.call_method(this, \"#{m.brat}\", #{a.result});
				}
				else
				{
					#@result = null;
				}
			} else {
				if($typeof(#{m.brat}) == $tfunction) {
					#@result = @brat.invoke(#{m.brat}, #{a.result});
				}
				else { #@result = #{m.brat} }
			};"

		end
	}
  end

  rule method_chain
 	(e:method_lhs ".")+ {
		def brat
			output = elements.first.e.brat
			last = elements.first.e.result
			@result = last
			meth = args = nil
			elements[1..-1].each do |elem|
				meth = elem.e.identifier.brat
				args = elem.e.arg_list
				output << args.brat
				next_temp
				output << "var #@result = @brat.call_method(#{last}, \"#{meth}\", #{args.result});"
				last = @result
			end
			output
		end
	}
	/
	expression3 "." method_chain
  end

  rule method_lhs
  	identifier !space arg_list a:("[" inner_arg_list "]")* {
		def brat
			next_temp
			output = arg_list.brat <<
			"var #@result;" <<
			"if(@brat.has_field(this, \"#{identifier.brat}\")) {" <<
			" #@result = @brat.call_method(this, \"#{identifier.brat}\", #{arg_list.result});" <<
			"}" <<
			"else " <<
			" if($typeof(#{identifier.brat}) == $tfunction) {" <<
			" #@result = @brat.invoke(#{identifier.brat}, #{arg_list.result});" <<
			" } else if($typeof(#{identifier.brat}) == $tobject) { " <<
			"  #@result = #{identifier.brat}}" <<
			"else { throw \"Tried to invoke method on #{identifier.brat}\" };"
			last = @result
			if not a.elements.empty?
				a.elements.each do |elem|
					output << elem.inner_arg_list.brat
					next_temp
					output << "var #@result = @brat.call_method(#{last}, \"__get\", #{elem.inner_arg_list.result});"
					last = @result
				end
			end
			output
		end	
	}
  end

  rule method_access
  	"->" m:identifier {
		def brat
			next_temp
			if var_exist? m.brat
				"var #@result;
				if($typeof(#{m.brat}) == $tfunction) {
					#@result = #{m.brat};
				}
				else
				{
					throw(\"Not a function: #{m.brat}\");
				};"
			else	
				"var #@result = $objget(this, $hash(\"#{m.brat}\"));"
			end
		end
	}
	/
  	o:method_invocation "->" m:identifier {
		def brat
			next_temp
			o.brat <<
			"var #@result = $objget(#{o.result}, $hash(\"#{m.brat}\"));"
		end
	}
  end

  rule arg_list
	'(' inner_arg_list ')' {
		def brat
			output = inner_arg_list.brat
			@result = inner_arg_list.result
			output
		end
	}
	/
	'(' empty_list ')' {
		def brat
			next_temp
			"var #@result = $amake(0);"
		end
	}
	/
  	space inner_arg_list {
		def brat
			output = inner_arg_list.brat
			@result = inner_arg_list.result
			output
		end
	}
	/
	![\(] space? {
		def brat
			next_temp
			"var #@result = $amake(0);"
		end

		def nothing?
			true
		end
	}
  end

  rule inner_arg_list
  	e:arg_first o:arg_next* {
		def brat
			output = ""
			args = []
			named_args = []

			if e.respond_to? :named_argument?
				output << e.brat
				named_args << e
			else
				output << e.brat
				args << e.result
			end

			o.elements.each do |elem|
				if elem.respond_to? :brat
					if elem.arg_first.respond_to? :named_argument?
						output << elem.arg_first.brat
						named_args << elem.arg_first
					else
						output << elem.brat
						args << elem.result
					end
				end
			end
			unless named_args.empty?
				next_temp
				hash_temp = @result
				output << "var #{hash_temp} = $hnew(#{named_args.length});"
				named_args.map do |e|
					output << "$hset(#{hash_temp}, \"#{e.i.brat}\", #{e.result}, null);"
				end
				next_temp
				output << "var #@result = @brat.make_hash(#{hash_temp});"
				args << @result
			end
			next_temp
			output << "var #@result = $array(#{args.join(',')});"
		end
	}
  end

  rule arg_first
	named_argument / expression
  end

  rule arg_next
  	space? "," space? arg_first {
		def brat
			output = arg_first.brat
			@result = arg_first.result
			output
		end
	}
  end

  rule named_argument
  	i:identifier space? ":" space? e:expression {
		def brat
			output = e.brat
			@result = e.result
			output
		end

		def named_argument?
			true
		end
	}
  end

  rule empty_list
  	space? {
		def brat
			nil
		end
	}
  end

  rule eol
	"\n"+ / ";"+ / "\r\n"+ {
		def brat
			"\n"
		end
	}
  end

  rule space
     (" " / "\t")+ {
		def brat
			text_value
		end
	}
  end
  
  rule eof
  	(eol / space)? !. {
		def brat
			""
		end
	}
  end

  rule eob
  	space? &"}" space? {
		def brat
			nil
		end
	}
  end
end
