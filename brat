#!/usr/bin/env ruby
BRAT_VERSON = 20090410

#This is for Ruby 1.8.6 compatibility
unless 0.respond_to? :even?
	class Fixnum
		def even?
			self % 2 == 0
		end
	end
end

#Compiles parser if it needs to be. Returns false if compilation does not occur, otherwise returns result of compilation.
def compile_parser force = false
	if force or not File.exist? "#$program_path/parser/brat.rb" or newer? "#$program_path/parser/brat.treetop", "#$program_path/parser/brat.rb"
		system "cd #$program_path/parser && tt brat.treetop"
	else
		false
	end
end

#Compiles internal.neko if needed. Returns false if compilation does not occur, otherwise returns result of compilation.
def compile_brat_internal force = false
	if force or not File.exist? "#$program_path/core/internal.n" or newer? "#$program_path/core/internal.neko", "#$program_path/core/internal.n"
		system "nekoc #$program_path/core/internal.neko" or abort "Error while compiling internal.neko"
		system "nekoc -z #$program_path/core/internal.n" or abort "Error while compiling internal.neko"
	else
		false
	end
end

#Compiles core.brat if needed. Returns false if compilation does not occur, otherwise returns result of compilation.
def compile_core force = false
	if force or not File.exist? "#$program_path/core/core.n" or newer? "#$program_path/core/core.brat", "#$program_path/core/core.n"
		File.open "#$program_path/core/core.neko", "w" do |f|
			parser = BaseBratParser.new
			tree = parser.parse(File.read("#$program_path/core/core.brat"))
			abort "Error parsing core: \n#{parser.terminal_failures.join("\n")}" if tree.nil?
			f.puts tree.core_brat
		end

		system "nekoc #$program_path/core/core.neko" or abort "Error while compiling core.brat"
		system "nekoc -z #$program_path/core/core.n"
		File.delete "#$program_path/core/core.neko"
	else
		false
	end
end

#Compiles stdlibs if needed. Returns false if compilation does not occur.
def compile_stdlib force = false
	neko_files = Dir.glob "#$program_path/stdlib/*.neko"
	brat_files = Dir.glob "#$program_path/stdlib/*.brat"
	options = {:force => true}

	if force
		neko_files.each do |f|
			system "nekoc #{f}"
		end

		brat_files.each do |f|
			compile_brat_file f, options
		end
		true
	else
		compiled = false
		neko_files.each do |f|
			fcomp = f[0..-4]
			if not File.exist? fcomp or newer? f, fcomp
				compiled = true
				system "nekoc #{f}" or abort "Error compiling #{f}"
				system "nekoc -z #{fcomp}"
			end
		end

		brat_files.each do |f|
			fcomp = f[0..-5] + "n"
			if not File.exist? fcomp or newer? f, fcomp
				compiled = true
				compile_brat_file f
			end
		end
		compiled
	end
end

#Parses Brat input and returns Neko code from the parser.
def brat_to_neko input
	parser = BaseBratParser.new
	tree = parser.parse(input)
	if tree.nil? or not tree.respond_to? :brat
		raise "Error during parsing:\n#{parser.terminal_failures.join("\n")}\n#{tree.inspect}"
	else
		tree.brat
	end
end

#Checks if file1 is newer than file2
def newer? file1, file2
	File.mtime(file1) > File.mtime(file2)
end

#Compiles and runs code from a single Brat file
def brat orig_file_name, options
	require 'rubygems'
	require 'treetop'

	force = options[:force]
	new_parser = compile_parser(force) unless options[:skip_check]

	require "#$program_path/parser/brat"
	require "#$program_path/parser/parser-extension"

	unless options[:skip_check]
		new_internal = compile_brat_internal(force) 
		new_core = compile_core(force)
		new_stdlib = compile_stdlib(force)
		force = force || new_parser || new_internal || new_core || new_stdlib
	end

	options[:force] = force

	file_name = compile_brat_file orig_file_name, options

	if not system "neko #{options[:stats] ? "-stats" : ""} #{file_name}.n"
		abort "Running program returned error number: #{$?}"
	end
end

#Compiles a Brat file to Neko bytecode, returns base name of file
def compile_brat_file orig_file_name, options = {}

	if orig_file_name.match /\.brat$/i
		file_name = orig_file_name[0..-6]
	else
		file_name = orig_file_name
	end

	force = options[:force]

	if force or not File.exist?(file_name + ".n") or newer? orig_file_name, file_name + ".n"
		if force or not File.exist? file_name + ".neko" or newer? orig_file_name, file_name + ".neko"
			brat_input = File.read orig_file_name
			begin
				neko = brat_to_neko brat_input
			rescue RuntimeError => e
				puts e
				exit
			end

			File.open(file_name + ".neko", "w") {|f| f.puts neko }
		end

		system "nekoc #{file_name}.neko" or abort "Error while compiling program"
	end

	if File.exist? file_name + ".neko"
		if not options[:keep_intermediate]
			File.delete file_name + ".neko"
		elsif options[:pretty]
			system "nekoc -p #{file_name}.neko"
			system "mv #{file_name}2.neko #{file_name}.neko"
		end
	end

	unless options[:nostrip]
		system "nekoc -z #{file_name}.n"
	end

	file_name
end
#Returns Neko code for Brat input, but without the Neko code it is usually wrapped in.
def inner_brat input

	parser = BaseBratParser.new
	tree = parser.parse(input)
	if tree.nil? or not tree.respond_to? :brat
		raise "Error during parsing:\n#{parser.terminal_failures.join("\n")}\n#{tree.inspect}"
	else
		tree.inner_brat
	end
end

#Runs the interactice Brat shell.
def brat_interactive options = {}
	require 'rubygems'
	require 'treetop'

	force = options[:force]
	compile_parser force
	compile_brat_internal force

	require "#$program_path/parser/brat"
	require "#$program_path/parser/parser-extension"

	compile_core force
	compile_stdlib force
	$interactive = true

	brat_console = IO.popen "#$program_path/bin/neko_console", "r+"
	brat_console.gets

	current = 0
	prompt = ">"
	line = ""
	puts "Warning: some code may not run accurately in interactive mode."
	loop do
		current += 1

		begin
			next_line = read_line("brat:#{current}#{prompt} ") 
		rescue Interrupt
			puts "Interrupted - exiting"
			unless brat_console.closed?
				brat_console.print "!quit\n\1" rescue nil
			end
			exit
		end

		if next_line.nil?
			puts
			next
		end

		line << next_line

		stripped = line.strip

		if stripped.empty?
			next
		elsif not line_closed? line
			prompt = "?"
			next
		elsif stripped == "quit" or stripped == "exit"
			brat_console.print "!quit\n\1"
			exit
		elsif stripped == "restart"
			brat_console.print "!quit\n\1"
			exec "brat"
		end

		begin
			neko = inner_brat line
		rescue Exception => e
			puts "Parsing error: #{e}"
			line = ""
			prompt = ">"
			next
		end

		#Send to neko console
		begin
			brat_console.print neko
			brat_console.print "\1"
		rescue Errno::EPIPE
			puts "Error - Neko interpreter crashed. Restarting."
			brat_console = IO.popen "#$program_path/bin/neko_console", "r+"
			brat_console.gets
			current = 0
			prompt = ">"
			line = ""
			next
		rescue
			puts "Communication error with Neko."
			next
		end

		#read back from console
		loop do
			begin
				response = brat_console.read_nonblock(12024)
				print response.gsub("\1", "").gsub("\2", "")
				break if response.include? "\1" or response.nil?
				if response.include? "\2"
					brat_console.puts read_line("")
				end
			rescue Interrupt => e
				puts "Interrupted by user"
			rescue Errno::EAGAIN
				retry
			rescue Exception => e
				p e
				exit
			end
		end

		prompt = ">"
		line = ""
	end
end

#Reads a single line using Readline
def read_line prompt
	require 'readline' rescue nil

	if defined? Readline
		line = Readline::readline(prompt)
		Readline::HISTORY.push(line) unless line.nil?
		line
	else
		$stdin.gets
	end
end

#Checks if a line is 'finished'. For example, returns false if a string literal is still open.
def line_closed? line

	items = line.scan(/\{|\}|"|\(|\)|\[|\]/)

	count = Hash.new(0)
	items.each do |i|
		count[i] += 1
	end

	if not count['"'].even? or count["{"] != count["}"] or count["("] != count[")"] or count["["] != count["]"]
		false
	else
		true
	end
end

#Returns help string for Brat executable
def show_help
	puts <<-END
Usage: brat [options] [file_name]
Possible options:
-a    Force recompilation of everything
-f    Ignore existing .n file
-h    Show this help information
-k    Don't erase intermediate files (implies -f)
-p    Prettify Neko code (implies -k)
-r    Report Neko stats
-s    Skip checking for out-of-date files
-t    Report running time
-w    Start Neko web server in current directory
	END
end

#Full path to Brat executable
$program_path = File.dirname(File.expand_path(__FILE__))

#Set up paths for Neko
ENV['LD_LIBRARY_PATH'] ||= ""
ENV['LD_LIBRARY_PATH'] += ":#$program_path/lib/:" << Dir.pwd
ENV['NEKOPATH'] ||= ""
ENV['NEKOPATH'] += ":#$program_path/lib/:#$program_path/core/:#$program_path/stdlib/:" << Dir.pwd
ENV['PATH'] ||= ""
ENV['PATH'] += ":#$program_path/bin/:" << Dir.pwd

$interactive = false

if ARGV.include? '-w'
	exec "nekotools server #{ARGV[1..-1].join(" ")}"
elsif ARGV[0]
	require 'set'
	opt_args = Set.new(ARGV.select {|o| o[0,1] == '-' })
	options = {}

	if opt_args.include? "-d"
		system "nekoc -d #{ARGV[1]}"
		exit
	end

	options[:force] = opt_args.include? "-a"
	
	options[:skip_check] = opt_args.include? '-s'

	if opt_args.include? '-h'
		show_help
		exit
	elsif opt_args.include? ARGV[-1] or opt_args.include? '-i'
		brat_interactive options
	end

	file_name = Dir.pwd + "/" + ARGV[-1]

	if not File.exist? file_name
		abort "No such file: #{ARGV[-1]}"
	end
	
	options[:stats] = opt_args.include? '-r'
	
	options[:nostrip] = opt_args.include? '-z'

	options[:keep_intermediate] = options[:prettify] = opt_args.include?('-p')
	
	options[:keep_intermediate] ||= opt_args.include? '-k'

	if opt_args.include? '-f' or options[:force] or options[:keep_intermediate]
		File.delete(file_name.sub(/\.brat$/, "") << ".n") rescue nil
	end

	if opt_args.include? "-t"
		require 'benchmark'
		time = Benchmark.measure do
			brat file_name, options
		end
		puts time.format('Time: %t %r')
	else
		brat file_name, options
	end

else
	brat_interactive
end
