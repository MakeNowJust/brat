#* JSON Parsing
# Example:

  include :json

  some_json = ' { "animals" : [ "dog, "cat", "turtle"] } '

  json_parse some_json  #Result: [animals: [ "dog", "cat", "turtle"] ]
*#


include :scanner
include :assert, :assertions
include :json_helpers

unmatched = object.new

matched? = { val | val != unmatched }

parser = object.new

parser.init = { input |
  my.input = input
  s = scanner.new(input)

  my.set_pos = { pos |
    s.pos = pos
  }

  my.current_pos = { s.pos }

  my.scan = { matcher |
    s.scan matcher
  }
}

parser.parse = {
  trim_space
  result = parse_object
  true? matched?(result)
    { result }
    { result = parse_array
      true? matched?(result)
        { result }
        { null }
    }
}

parser.parse_number = {
  result = scan(/-?(0|[1-9]\d*)(\.\d+)?((e|E)(\+|-)?\d+)?\b/)
  true? result
    { result.full_match.to_f }
    { unmatched }
}

parser.parse_value = {
  result = null
  trim_space
  when { scan "true" } { true }
    { scan "false" } { false }
    { scan "null" } { null }
    { matched? result = parse_number } { result }
    { matched? result = parse_string } { result }
    { matched? result = parse_array } { result }
    { matched? result = parse_object } { result }
    { true } { unmatched }
}

parser.parse_string = {
  true? scan('"') {
    result = json_decode(my.input, my.current_pos)
    true? result
      { set_pos result[1]
        result[0] }
      { unmatched }
  }
  { unmatched }
}

parser.parse_array = {
  true? scan("[") 
  {
    result = null
    continue = true
    a = []
    while { continue && matched?(result = parse_value) } {
      a << result
      continue = scan ","
    }

    true? scan("]")
    { a }
    { unmatched }
  }
  { unmatched }
}

parser.parse_object = {
  true? scan(/{\s*/)
  {
    result = null
    key = null
    continue = true
    o = [:]

    while { continue && matched?(key = parse_string) } {
      true? scan(/\s*:\s*/) {
        o[key] = parse_value
        continue = scan(/\s*,\s*/)
      }
      {
        continue = false
      }
    }


    true? scan(/\s*}/)
    { o }
    { unmatched }
  }
  { unmatched }
}

parser.trim_space = { scan /\s+/ }

parse_json = { input |
  parser.new(input).parse
}

export ->parse_json "parse_json"
 
#*
include :assert :assertions
squish assertions

test = { input, method, value = unmatched |
  result = parser.new(input).call_method("parse_#{method}")
  assert matched?(result), "Failed to parse #{input} with #{method}"
  true? matched?(value)
    { assert_equal value, result }
}

test "0" :number 0
test "1" :number 1
test "1.1" :number 1.1
test "-0.5123" :number -0.5123
test "1e+10" :number

test "true" :value true
test "false" :value false
test "null" :value null
test "1" :value 1

test '"\""' :value "\""
test '"hello"' :string
test '"\u20AC"' :string
test '"\t"' :string

test '[]' :array []
test '[1]' :array [1]
test '[1,2]' :array [1, 2]
test '[1,2,3]' :array [1, 2, 3]
test '["x"]' :array ["x"]
test '[["x"]]' :array [["x"]]
test '[true]' :array [true]
test '[null,false]' :array [null, false]
test '["a",1,false]' :array ["a" 1 false]
test '[[1]]' :array [[1]]
test '[1,[2],[[["z"]]]]' :array [1, [2], [[["z"]]]]

test '{"x":1}' :object [x: 1]
test '{"x":1,"y":"z"}' :object [x: 1, y: :z]
test '{"x":1,"z":{"y":2}}', :object, [ x: 1, z: [y: 2] ]
test '{"Array":[1,2,3],"Object":{"nested":"objects"}}' :object [Array: [1 2 3], Object: [nested: :objects]]
