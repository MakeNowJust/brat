var tcreate = $loader.loadprim("std@thread_create", 2);
var lock_create = $loader.loadprim("std@lock_create", 0);
var lock_release = $loader.loadprim("std@lock_release", 1);
var lock_wait = $loader.loadprim("std@lock_wait", 2);
var mutex_create = $loader.loadprim("std@mutex_create", 0);
var mutex_acquire = $loader.loadprim("std@mutex_acquire", 1);
var mutex_try = $loader.loadprim("std@mutex_try", 1);
var mutex_release = $loader.loadprim("std@mutex_release", 1);
var queue_create = $loader.loadprim("std@deque_create", 0);
var queue_push = $loader.loadprim("std@deque_add", 2);
var queue_pop = $loader.loadprim("std@deque_pop", 2);
var queue_prepend = $loader.loadprim("std@deque_push", 2);

var @brat = $loader.loadmodule("internal", $loader);

var thread = @brat.base_object.new();
thread.@lock = null;
thread.@result = null;
thread.@finished = false;
thread.@all = @brat.base_array.new();
thread.@mutex = mutex_create();
mutex_release(thread.@mutex);
thread.new = function(block) {
	if($typeof(block) != $tfunction)
		$throw("Thread.new requires a function as its argument.");
	else if($nargs(block) != 0)
		$throw("Thread.new requires a function with zero arguments.");

	var t = @brat.new_brat(this);
	t.@lock = lock_create();
	var wrap = function(dummy) {
		try {
			t.@result = $call(block, @brat.base_object, $amake(0));
		}
		catch e {
			$print("Error in thread: ", e, "\n");
		}

		t.@finished = true;
		lock_release(t.@lock);
	}
	mutex_acquire(thread.@mutex);
	t.@thread = tcreate(wrap, null);
	thread.@all.push(t);
	mutex_release(thread.@mutex);

	t;
}

thread.join = function() {
	if(this.@lock == null)
		return null;
	
	lock_wait(this.@lock, null);

	mutex_acquire(thread.@mutex);
	thread.@all.delete@underfirst(this);
	mutex_release(thread.@mutex);

	lock_release(this.@lock);
	this.@result;
}

thread.result = function() {
	this.@result;
}

thread.finished@question = function() {
	if(this.@finished)
		@brat.base_object.@@true;
	else
		@brat.base_object.@@false;
}

thread.@join_all = $varargs(function(args) {
	var arglen = $asize(args);
	var wait_threads;
	var q;
	if(arglen > 0) {
		if(arglen == 1 && $typeof(args[0]) == $tobject && @brat.has_field(args[0], "@neko_array"))
			args = args[0].@neko_array();
		else if(arglen == 1 && $typeof(args[0]) == $tarray)
			args = args[0];

		arglen = $asize(args);
		q = queue_create();
		//pass in [thread, queue]
		var wrap = function(thq) {
			thq[0].join();
			queue_push(thq[1], thq[0]);
		}

		var i = 0;
		wait_threads = $amake(arglen);
		var current;
		while(i < arglen) {
			current = args[i];
			if($typeof(current) != $tobject)
				$throw("Invalid arguments to thread.@join_all(): " + $string(current));

			wait_threads[i] = tcreate(wrap, $array(current, q));

			i = i + 1;
		}
	}
	else
		$throw("Invalid arguments for thread.@join_all().");

	$array(wait_threads, q);
})

thread.wait@underall = $varargs(function(args) {
	var block;
	if($asize(args) == 1 && $typeof(args[0]) == $tfunction)
		block = args[0];
	else if($asize(args) != 0)
		$throw("Invalid argument for thread.wait_all(): requires either a block or nothing.");

	mutex_acquire(thread.@mutex);
	var threads = $acopy(thread.@all.@neko_array());
	mutex_release(thread.@mutex);
	
	if(block != null)
		thread.wait@underon(threads, block);
	else
		thread.wait@underon(threads);
})

var set = $loader.loadmodule("set", $loader).set;

thread.wait@underon = $varargs(function(args) {
	var arglen = $asize(args);
	if(arglen == 0)
		$throw("Thread.wait_all() requires some arguments!");
	else if(arglen == 1 && $typeof(args[0]) == $tobject && @brat.has_field(args[0], "@neko_array"))
		args = args[0].@neko_array();
	else if(arglen == 1 && $typeof(args[0]) == $tarray)
		args = args[0];
	else if(arglen == 2 && $typeof(args[0]) == $tarray && $typeof(args[1]) == $tfunction) {
		var temp = args;
		args = $amake($asize(args[0]) + arglen - 1);
		$ablit(args, 0, temp[0], 0, $asize(temp[0]));
		args[$asize(args) - 1] = temp[$asize(temp[0]) - 1];
		arglen = $asize(args);
	}
	else if(arglen == 2 && $typeof(args[0]) == $tobject && $typeof(args[1]) == $tfunction && @brat.has_field(args[0], "@neko_array")) {
		var temp = args;
		var temp_array = args[0].@neko_array();
		args = $amake($asize(temp_array) + 1);
		$ablit(args, 0, temp_array, 0, $asize(temp_array));
		args[$asize(temp_array)] = temp[1];
		arglen = $asize(args);
	}

	var joins;
	var block;
	if($typeof(args[arglen - 1]) == $tfunction) {
		joins = thread.@join_all($asub(args, 0, arglen - 1));
		block = args[arglen - 1];
	}
	else
		joins = thread.@join_all(args);

	var num_threads = $asize(joins[0]);
	var q = joins[1];

	var t;
	while(num_threads > 0) {
		t = queue_pop(q, true);
		num_threads = num_threads - 1;
		if(block != null)
			block(t.result());
	}

	@brat.base_object.@@null;
})

var queue = @brat.base_object.new();
queue.new = function() {
	var q = @brat.new_brat(this);
	q.@internal_queue = queue_create();
	q;
}

queue.push = function(item) {
	queue_push(this.@internal_queue, item);
}

queue.pop = function() {
	var res = queue_pop(this.@internal_queue, false);
	if(res == null)
		@brat.@@null;
	else
		res;
}

queue.wait@undernext = function() {
	queue_pop(this.@internal_queue, true);
}

queue.prepend = function(item) {
	queue_prepend(this.@internal_queue, item);
}

var mutex = @brat.base_object.new();
mutex.new = function() {
	var m = @brat.new_brat(this);
	m.@mutex = mutex_create(); 
	m;
}

mutex.synchronize = function(block) {
	mutex_acquire(this.@mutex);
	var res = block();
	mutex_release(this.@mutex);
}

$exports.thread = thread;
$exports.queue = queue;
$exports.mutex = mutex;
