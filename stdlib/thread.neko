var tcreate = $loader.loadprim("std@thread_create", 2);
var lock_create = $loader.loadprim("std@lock_create", 0);
var lock_release = $loader.loadprim("std@lock_release", 1);
var lock_wait = $loader.loadprim("std@lock_wait", 2);

var @brat = $loader.loadmodule("internal", $loader);

var thread = @brat.base_object.new();
thread.@lock = null;
thread.@result = null;
thread.@finished = false;
thread.@all = @brat.base_array.new();
thread.new = function(block) {
	if($typeof(block) != $tfunction)
		$throw("Thread.new requires a function as its argument.");
	else if($nargs(block) != 0)
		$throw("Thread.new requires a function with zero arguments.");

	var t = @brat.new_brat(this, null);
	t.@lock = lock_create();
	var wrap = function(dummy) {
		try {
			t.@result = $call(block, @brat.base_object, $amake(0));
		}
		catch e {
			$print(e, "\n");
		}
		lock_release(t.@lock);
		t.@finished = true;
	}
	t.@thread = tcreate(wrap, null);
	t;
}

thread.join = function() {
	if(this.@lock == null)
		return null;
	
	lock_wait(this.@lock, null);
	lock_release(this.@lock);
	this.@result;
}

thread.result = function() {
	this.@result();
}

thread.finished@question = function() {
	if(this.@finished || this.@thread == null)
		@brat.base_object.@true();
	else
		@brat.base_object.@false();
}

$exports.thread = thread;
