enumerable = new

enumerable.any? = { block |
	flag = false
	my.each { o |
		false? flag, 
			{ true? block(o), { flag = true } }
	}
	flag
}

enumerable.all? = { block |
	flag = true
	my.each { o |
		true? flag, 
			{ false? block(o), { flag = false } }
	}
	flag
}

enumerable.find = { block |
	found = null
	my.each { o |
		null? found,
			{ true? block(o), { found = o } }
	}
	found
}

enumerable.select = { block |
	new_ary = []
	my.each { i |
		true? block(i), { new_ary << i }
	}
	new_ary
}

enumerable.sort = {
	my.to_array.sort
}

enumerable.to_array = {
	new_ary = []
	index = 0
	my.each { o |
		new_ary[index] = o
		index = index + 1
	}
	new_ary
}


export enumerable, "enumerable"

array.my_sort = array->sort

array.squish enumerable

array.sort = array->my_sort;

array.to_array = {
	my
}

array.first = { my[0] }
array.rest = { my[1,-1] }
array.last = { my[-1] }

array.map = { block |
	new_ary = []
	false? my.empty?, 
		{
			index = 0
			length = my.length
			
			true? function?(->block),
				{ while {
					new_ary << block(my[index])
					index = index + 1
					index < length
				}},
				{ while {
					new_ary << my[index].call_method block
					index = index + 1
					index < length
				}}
		}
	new_ary
}

array.map_with_index = { block |
	new_ary = []
	false? my.empty?, 
		{ 
			index = 0
			length = my.length
			while {
				new_ary << block(my[index], index)
				index = index + 1
				index < length
			}
		}
	new_ary
}

array.each = { block |
	false? my.empty?, 
		{
			index = 0
			length = my.length
			while {
				block my[index]
				index = index + 1
				index < length
			}
		}
	my
}


array.reverse_each = { block |
	false? my.empty?, 
		{
			index = my.length
			length = my.length
			while {
				index = index - 1
				block my[index]
				index > 0
			}
		}
	my
}

array.each_with_index = { block |
	false? my.empty?, 
		{
			index = 0
			length = my.length
			while {
				block my[index], index
				index = index + 1
				index < length
			}
		}
	my
}

array.empty? = { my.length == 0 }

array.include? = { item |
	true? my.empty?, 
		{ false },
		{ 
			found = false
			index = 0
			length = my.length
			while {
				found = (my[index] == item)
				index = index + 1
				not(found) && { index < length }
			}
			found
		}
}

array.index_of = { item |
	true? my.empty?, 
		{ null },
		{ 
			found = false
			index = 0
			length = my.length
			while {
				found = my[index] == item
				index = index + 1
				not(found) && { index < length }
			}
			true? found, index, null
		}
}

array.rindex_of = { item |
	true? my.empty?, 
		{ null },
		{ 
			found = false
			index = my.length
			while {
				index = index - 1
				found = my[index] == item
				not(found) && { index > 0 }
			}
			true? found, index, null
		}
}

comparable = import "comparable"

string.squish comparable

number.squish comparable

number.times = { block |
	true? my > 0,
		{
			n = 0
			true? method_arity(->block) > 0,
				{ while {
					block n
					n = n + 1
					n < my
				}},
				{ while {
					block
					n = n + 1
					n < my
				}}
		}
	my
}

number.to = { stop, block |
	n = my
	true? n < stop,
		{
			while { n <= stop },
				{ block n; n = n + 1 }
		},
		{
			while { n >= stop },
				{ block n; n = n - 1 }
		}
	stop
}

object.&& = { rhs |
        true? my,
                { rhs },
                { false }
}

object.|| = { rhs |
	true? my,
		{ true },
		{ true? rhs }
}

