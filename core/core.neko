//base_object is _the_ base object for all objects
base_object = $new(null);

base_object.new = $varargs(function(args) {
	var nb = new_brat(this);
	if($objget(this, $hash("init")) != null) {
		var init = $objget(this, $hash("init"))
		if($nargs(init) == -2)
			nb.init(args);
		else
			$objcall(nb, $hash("init"), args);
	}
	else if($asize(args) > 0)
		$throw(base_exception.argument_error("object.new", 0, $asize(args)));
	
	nb;
})

//Create a new object with either parent_brat or base_object
//as the parent class.
new_brat = function(parent_brat) {
	var brat = $new(null);

	if(parent_brat == null)
		$objsetproto(brat, base_object);
	else 
		$objsetproto(brat, parent_brat);

	brat;
}

/*
base_object.clone = function() {
	var brat = $new(this);
	$objsetproto(brat, $objgetproto(this));
	brat;
}
*/

base_object.my = function() {
	return this;
}

base_object.parent = function() {
	var parent = $objgetproto(this);
	if(parent == null)
		base_object;
	else
		parent;
}

base_object.to@unders = function() {
	var fields = $objfields(this);
	var index = 0;
	var length = $asize(fields);
	var vals = $hnew(length);
	var cur_field;
	var name;
	var first;
	var output = "#object<"
	while index < length {
		cur_field = fields[index];
		name = $field(cur_field);
		if(name == null)
			name = "null"; //I don't know why this would happen, but it did
		name = from_identifier(name);
		first = $ssub(name, 0, 1);
		if(first != "@" && first != "_")
			output = output + " " + name;
		index = index + 1;
	} 
	base_string.new(output + " >");
}

base_object.@to_s = function() {
	this.to@unders().@value;
}

base_object.__string = function() {
	this.@to_s();
};

base_object.print = $varargs(function(args) {
	var i = 0;
	var len = $asize(args);
	while i < len {
		if($objget(args[i], $hash("@to_s")) != null)
			args[i] = args[i].@to_s();
		else if(base_number.@is_number(args[i]))
			args[i] = base_number.@to_s(args[i]);
		i += 1;
	};
	$call($print, null, args);
	base_object.@@null;
})

base_object.p = $varargs(function(args) {
	var pargs = $aconcat($array(args, $array("\n")));
	$call(this.print, null, pargs);
})

base_object.squish = function(object) {
	if($typeof(object) != $tobject)
		$throw(base_exception.argument_error("object.squish", "object", object));

	var fields = $objfields(object);
	var num_fields = $asize(fields);
	var i = 0;
	while( i < num_fields) {
		var fval = $objget(object, fields[i]);
		if($typeof(fval) == $tfunction) {
			$objset(this, fields[i], fval);
		}
		i = i + 1;
	}
	this;
}

base_object.@function@question = function(object) {
	if($typeof(object) == $tfunction)
		base_object.@@true;
	else
		base_object.@@false;
}

base_object.object@question = function(object) {
	if($typeof(object) == $tobject)
		base_object.@@true;
	else
		base_object.@@false;
}

random = $loader.loadprim("std@random_new", 0);
random_int = $loader.loadprim("std@random_int", 2);
base_object.random = function(max) {
	if(base_number.@is_number(max)) {
		if($typeof(max) == $tint)
			random_int(random(), max);
		else
			$throw(base_exception.argument_error("random", "integer", max));
	}
	else
		$throw(base_exception.argument_error("random", "number", x));
}

stdin = $loader.loadprim("std@file_stdin", 0);
read_line = $loader.loadprim("std@file_gets", 1);
buffer_new = $loader.loadprim("std@buffer_new", 0);
buffer_add_char = $loader.loadprim("std@buffer_add_char", 2);
buffer_string = $loader.loadprim("std@buffer_string", 1);
base_object.g = $varargs(function(args) {
	var break_char = 10;
	if($asize(args) == 1) {
		if($typeof(args[0]) == $tobject && $objget(args[0], $hash("@neko_string")) != null && $ssize(args[0].@value) == 1)
			break_char = $sget(args[0], 0)
		else
			$throw(base_exception.argument_error("g", "single character", args[0]));
	}
	else if($asize(args) > 1) {
		$throw(base_exception.argument_error("g", "0 or 1", $asize(args)));
	}

	try {
		line = read_line(stdin());
        }
	catch e {
		return base_object.@@null;
	}
        base_string.new(line);
})

//True, false, and null values
base_object.@@false = new_brat(null);
base_object.@false = function() { base_object.@@false }
base_object.@@false.to@unders = function() { base_string.new("false") };
base_object.@@true = new_brat(null);
base_object.@true = function() { base_object.@@true }
base_object.@@true.to@unders = function() { base_string.new("true") };
base_object.@@null = new_brat(null);
base_object.@null = function() { base_object.@@null }
base_object.@@null.to@unders = function() { base_string.new("null") };

base_object.@equal@equal = function(rhs) {
	if($pcompare(this, rhs) == 0)
		base_object.@@true;
	else if($objget(this, $hash("@less@equal@greater")) != null) {
		if(this.@less@equal@greater(rhs) == 0)
			base_object.@@true;
		else
			base_object.@@false;
	}
	else {
		if($pcompare(this, rhs) == 0) {
			base_object.@@true;
		}
		else
			base_object.@@false;
	}
}

base_object.@notequal = function(rhs) {
	base_object.not(this.@equal@equal(rhs));
}

istrue = function(arg) {
	if(arg == base_object.@@null || arg == base_object.@@false) {
		false;
	}
	else {
		true;
	}
}

base_object.@true@question = $varargs(function(args) {
	switch $asize(args) {
		0 => this.@0_@true@question()
		1 => this.@1_@true@question(args[0])
		2 => this.@2_@true@question(args[0], args[1])
		3 => this.@3_@true@question(args[0], args[1], args[2])
		default => $throw(base_exception.argument_error("true?", "0 - 3", $asize(args)))
	}
})

base_object.@0_@true@question = function() {
	if(istrue(this))
		base_object.@@true;
	else
		base_object.@@false;
	
}

base_object.@1_@true@question = function(condition) {
	var first;
	if($typeof(condition) == $tfunction) {
		first = condition();
	}
	else {
		first = condition
	}

	if(istrue(first))
		base_object.@@true;
	else
		base_object.@@false;
}


base_object.@2_@true@question = function(condition, true_branch) {
	var first;
	if($typeof(condition) == $tfunction) {
		first = condition();
	}
	else {
		first = condition
	}

	if(istrue(first)) {
		if($typeof(true_branch) == $tfunction) {
			true_branch();
		}
		else {
			true_branch;
		}
	}
	else {
		first;
	}
}

base_object.@3_@true@question = function(condition, true_branch, false_branch) {
	var first;
	if($typeof(condition) == $tfunction) {
		first = condition();
	}
	else {
		first = condition
	}

	if(istrue(first)) {
		if($typeof(true_branch) == $tfunction) {
			true_branch();
		}
		else {
			true_branch;
		}
	}
	else {
		if($typeof(false_branch) == $tfunction) {
			false_branch();
		}
		else {
			false_branch;
		}
	}
}

base_object.@false@question = $varargs(function(args) {
	switch $asize(args) {
		0 => this.@0_@false@question()
		1 => this.@1_@false@question(args[0])
		2 => this.@2_@false@question(args[0], args[1])
		3 => this.@3_@false@question(args[0], args[1], args[2])
		default => $throw(base_exception.argument_error("false?", "0 - 3", $asize(args)))
	}
})


base_object.@0_@false@question = function() {
	if($not(istrue(this)))
		base_object.@@true;
	else
		base_object.@@false;
}

base_object.@1_@false@question = function(condition) {
	var first;
	if($typeof(condition) == $tfunction) {
		first = condition();
	}
	else {
		first = condition
	}

	if($not(istrue(first)))
		base_object.@@true;
	else
		base_object.@@false;
}


base_object.@2_@false@question = function(condition, false_branch) {
	var first;
	if($typeof(condition) == $tfunction) {
		first = condition();
	}
	else {
		first = condition
	}

	if($not(istrue(first))) {
		if($typeof(false_branch) == $tfunction) {
			false_branch();
		}
		else {
			false_branch;
		}
	}
	else {
		first;
	}
}

base_object.@3_@false@question = function(condition, false_branch, true_branch) {
	var first;
	if($typeof(condition) == $tfunction) {
		first = condition();
	}
	else {
		first = condition
	}

	if($not(istrue(first))) {
		if($typeof(false_branch) == $tfunction) {
			false_branch();
		}
		else {
			false_branch;
		}
	}
	else {
		if($typeof(true_branch) == $tfunction) {
			true_branch();
		}
		else {
			true_branch;
		}

	}
}

base_object.@null@question = $varargs(function(args) {
	switch $asize(args) {
		0 => this.@0_@null@question()
		1 => this.@1_@null@question(args[0])
		2 => this.@2_@null@question(args[0], args[1])
		3 => this.@3_@null@question(args[0], args[1], args[2])
		default => $throw(base_exception.argument_error("null?", "0 - 3", $asize(args)))
	}
})

base_object.@0_@null@question = function() {
	if(this == base_object.@@null)
		base_object.@@true;
	else
		base_object.@@false;
}

base_object.@1_@null@question = function(condition) {
	var first;
	if($typeof(condition) == $tfunction) {
		first = condition();
	}
	else {
		first = condition
	}
	
	if(first == null || first == base_object.@@null)
		base_object.@@true;
	else 
		base_object.@@false;
}

base_object.@2_@null@question = function(condition, null_branch) {
	var first;
	if($typeof(condition) == $tfunction) {
		first = condition();
	}
	else {
		first = condition
	}

	if(first == null || first == base_object.@@null) {
		if($typeof(null_branch) == $tfunction) {
			null_branch();
		}
		else {
			null_branch;
		}
	}
	else {
		base_object.@@false;
	}
}

base_object.@3_@null@question = function(condition, null_branch, else_branch) {
	var first;
	if($typeof(condition) == $tfunction) {
		first = condition();
	}
	else {
		first = condition
	}

	if(first == null || first == base_object.@@null) {
		if($typeof(null_branch) == $tfunction) {
			null_branch();
		}
		else {
			null_branch;
		}
	}
	else {
		if($typeof(else_branch) == $tfunction) 
			else_branch();
		else
			else_branch;
	}
}

base_object.not = function(arg) {
	if(istrue(arg)) {
		base_object.@@false;
	}
	else
	{
		base_object.@@true;
	}
}

base_object.@while = $varargs(function(args) {
	switch $asize(args) {
		1 => this.@1_@while(args[0])
		2 => this.@2_@while(args[0], args[1])
		default => $throw(base_exception.argument_error("while", "1 or 2", $asize(args)))
	}
})

base_object.@1_@while = function(block) {
	while(istrue(block())) {}
}

base_object.@2_@while = function(condition, block) {
	while(($typeof(condition) == $tfunction && istrue(condition())) || ($typeof(condition) != $tfunction && istrue(condition))) { block() }
}

base_object.@and@and = function(rhs) {
	if(istrue(this)) {
		if($typeof(rhs) == $tfunction)
			rhs = rhs();

		if(istrue(rhs))
			base_object.@@true;
		else
			base_object.@@false;
	}
	else
		base_object.@@false;
}

base_object.@or@or = function(rhs) {
	if(istrue(this))
		base_object.@@true;
	else {
		if($typeof(rhs) == $tfunction)
			rhs = rhs();

		if(istrue(rhs))
			base_object.@@true;
		else
			base_object.@@false;
	}
}

base_object.@check_equal = function(lhs, rhs) {
	var t = $typeof(lhs);
	if(t == $tobject)
		istrue(lhs.@equal@equal(rhs))
	else if(t == $tint || is_num(lhs))
		istrue(base_number.@equal@equal(lhs, rhs))
	else
		$throw(base_exception.new("Cannot compare " + $string(lhs) + " and " + $string(rhs)));
}

base_object.when = $varargs(function(args) {
	var arglen = $asize(args);
	if(arglen < 2) {
		$throw(base_exception.argument_error("when", "at least 2", arglen));
	} 
	var index;
	var check;

	if(arglen % 2 == 0) {
		index = 0;
		check = function(condition) {
			if($typeof(condition) == $tfunction) {
				condition = condition();
			}

			istrue(condition);
		}
	}
	else {
		index = 1;
		var value = args[0];
		check = function(condition) {
			if($typeof(condition) == $tfunction)
				base_hash.@compare(value, condition()) == 0;
			else
				base_hash.@compare(value, condition) == 0;
		}
	}

	while(index < arglen) {
		if(check(args[index])) {
			var action = args[index + 1];

			if($typeof(action) == $tfunction) {
				if($nargs(action) == 0)
					return action();
			}
			else
				return action;
		}
		else {
			index = index + 2;
		}
	}

	return base_object.@@null;
})

base_object.include = $varargs(function(args) {
	this.squish($objcall(this, $hash("import"), args));
})

base_object.import = $varargs(function(args) {
	if($asize(args) == 1) {
		if($objget(args[0], $hash("@neko_string")) != null) {
			var m;
			try {
				m = $loader.loadmodule(to_identifier(args[0]), $loader);
			}
			catch e {
				$throw(base_exception.new(e));
			}
			var imp = base_object.new();
			var f = $objfields(m);
			var fs = $asize(f);
			var index = 0;
			var field;
			while(index < fs) {
				field = $objget(m, f[index]);
				if($typeof(field) == $tobject)
					$objset(imp, f[index], function() { field });
				else if($typeof(field) == $tfunction)
					$objset(imp, f[index], field);
				else if($field(f[index]) == "__module") {}
				else
					$throw(base_exception.new("Cannot import: " + $string($field(f[index]))));

				index = index + 1;
			}
			imp;
		}
		else
			$throw(base_exception.argument_error("import", "string", args[0]));
	}
	else if($asize(args) == 2) {
		if($objget(args[0], $hash("@neko_string")) != null && $objget(args[1], $hash("@neko_string")) != null) {
			var m = $loader.loadmodule(args[0].@value, $loader);
			var name = $hash(to_identifier(args[1]));
			if($objfield(m, name)) {
				$objget(m, name);
			}
			else
				$throw(base_exception.new("Module " + args[0].@value + " does not have an export named " + args[1].@value));
		}
		else
			$throw(base_exception.argument_error("import", "two string", args));
	}
	else
		$throw(base_exception.argument_error("import", "1 or 2", $asize(args)));
})

base_object.add@undermethod = function(name, block) {
	name = to_identifier(name);

	$objset(this, $hash(name), block);
	this;
}

base_object.del@undermethod = function(name) {
	name = to_identifier(name);
	$objremove(this, $hash(name));
	this;
}

base_object.get@undermethod = function(name) {
	var m = $objget(this, $hash(to_identifier(name)));

	if(m == null) {
		var proto = $objgetproto(this);
        	if(proto == null) {
			base_object.@@null;
        	}
	        else {
			proto.get@undermethod(name);
	        }
	}		
	else
		m;
}

base_object.has@undermethod@question = function(name) {
	if($objget(this, $hash(to_identifier(name))) == null)
		base_object.@@false;
	else
		base_object.@@true;
}

base_object.call@undermethod = $varargs(function(args) {
	var arglen = $asize(args);
	if(arglen < 1)
		$throw(base_exception.argument_error("call_method", "at least one", arglen));

	var m = this.get@undermethod(args[0]);

	if(m == base_object.@@null)
		$throw(base_exception.method_error(this, args[0])); 

	var nargs = $nargs(m);
	if(nargs != -1 && nargs != arglen - 1)
		$throw(base_exception.argument_error(args[0], nargs, arglen));

	if(arglen > 1)
		$call(m, this, $asub(args, 1, arglen - 1));
	else
		$call(m, this, $amake(0));
});

base_object.methods = function() {
	var meths = $objfields(this);
	var i = 0; 
	var field;
	var name;
	while(i < $asize(meths)) {
		field = $field(meths[i]);
		if(field == null)
			$throw(base_exception.new("Unable to retrieve string for field, for some weird reason."));
		name = from_identifier(field);
		meths[i] = base_string.new(name);
		i = i + 1;
	}

	var proto = $objgetproto(this);
	meths = base_array.new(meths).select(function(i) { base_object.not(i[0].@equal@equal(base_string.new("@")))});
	if(proto == null)
		meths;
	else {
		meths.@plus(proto.methods());
	}
}

base_object.local@undermethods = function() {
	var meths = $objfields(this);
	var i = 0; 
	var field;
	var name;
	while(i < $asize(meths)) {
		field = $field(meths[i]);
		if(field == null)
			$throw(base_exception.new("Unable to retrieve string for field, for some weird reason."));
		name = from_identifier(field);
		meths[i] = base_string.new(name);
		i = i + 1;
	}

	meths = base_array.new(meths).select(function(i) { base_object.not(i[0].@equal@equal(base_string.new("@")))});
}

base_object.with@underthis = function(block) {
	block();
}

base_object.method@underarity = function(func) {
	if($typeof(func) == $tfunction) {
		var args = $nargs(func);
		if(args < 0)
			0-1;
		else
			args;
	}
	else
		$throw(base_exception.new($string(func) + " is not a function, cannot report its arity."));
}

base_object.tap = function(block) {
	if($typeof(block) == $tfunction) {
		var args = $nargs(block);
		if(args < 1)
			block();
		else if(args == 1)
			block(this);
		else
			$throw(base_exception.argument_error("object.tap", "function taking a single argument", block));
	}
	else
		$throw(base_exception.argument_error("object.tap", "function taking a single argument", block));

	this;
}

sys_exit = $loader.loadprim("std@sys_exit", 1);
base_object.exit = $varargs(function(exit_code) {
	if($asize(exit_code) == 0)
		sys_exit(0);
	else if($asize(exit_code) == 1) {
		exit_code = exit_code[0];
		if($typeof(exit_code) == $tint)
			sys_exit(exit_code);
		else
			$throw(base_exception.argument_error("exit", "integer", exit_code[0]));
	}
	else {
		$throw(base_exception.argument_error("exit", "0 or 1", $asize(exit_code)));
	}

});

sys_sleep = $loader.loadprim("std@sys_sleep", 1);
base_object.sleep = function(seconds) {
	if($typeof(seconds) != $tint && $typeof(seconds) != $tfloat)
		$throw(base_exception.argument_error("sleep", "number", seconds));

	sys_sleep(seconds);
}

has_field = function(object, field_name) {
	$objget(object, $hash(field_name)) != null
}

//Comparable squishin
comparable = new_brat(null);

comparable.@greater = function(num) {
	if(this.@less@equal@greater(num) == 1)
		base_object.@@true;
	else
		base_object.@@false;
}

comparable.@less = function(num) {
	if(this.@less@equal@greater(num) == -1)
		base_object.@@true;
	else
		base_object.@@false;
}

comparable.@less@equal = function(num) {
	if(this.@less@equal@greater(num) < 1)
		base_object.@@true;
	else
		base_object.@@false;
}

comparable.@greater@equal = function(num) {
	if(this.@less@equal@greater(num) > -1)
		base_object.@@true;
	else
		base_object.@@false;
}

//Number functions
f_from_s = $loader.loadprim("number@float_from_string", 1);
i_from_s = $loader.loadprim("number@integer_from_string", 1);
num_add = $loader.loadprim("number@num_add", 2);
num_sub = $loader.loadprim("number@num_sub", 2);
num_mul = $loader.loadprim("number@num_mul", 2);
num_div = $loader.loadprim("number@num_div", 2);
int_pow = $loader.loadprim("number@int_pow", 2);
num_cmp = $loader.loadprim("number@num_cmp", 2);
is_num = $loader.loadprim("number@is_num", 1);
is_int = $loader.loadprim("number@is_int", 1);
is_float = $loader.loadprim("number@is_float", 1);
num_to_string = $loader.loadprim("number@num_to_string", 1);
num_to_float = $loader.loadprim("number@int_to_float", 1);
float_to_int = $loader.loadprim("number@float_to_int", 1);
integer_from_int = $loader.loadprim("number@integer_from_int", 1);
float_from_float = $loader.loadprim("number@float_from_float", 1);
num_neg = $loader.loadprim("number@num_neg", 1);
to_neko_num = $loader.loadprim("number@to_neko_num", 1);
to_bignum = $loader.loadprim("number@to_bignum", 1);
integer_fits = $loader.loadprim("number@integer_fits_native", 1);

base_number = new_brat(null);

base_number.@is_number = function(num) {
	if($typeof(num) == $tint)
		true
	else if($typeof(num) == $tabstract && is_num(num))
		true
	else
		false
}

base_number.@to_s = function(num) {
	str = base_number.to@unders(num).@neko_string();
}

base_number.to@unders = function(num) {
	if($typeof(num) == $tint)
		return base_string.new($string(num));
	var s = num_to_string(num);
	var str = base_string.new(s);
	if($sfind(str.@value, 0, ".") != null) {
		var r = base_regex.new("\\.?0+$");
		str.sub@underfirst@bang(r, "");
	}
	str;
}

base_number.native@question = function(num) {
	if($typeof(num) == $tint)
		base_object.@@true;
	else
		base_object.@@false;
}

base_number.to@underi = function(num) {
	var res = to_bignum(num);
	res = float_to_int(res);
	base_number.new(res);
}

base_number.to@underf = function(num) {
	if($typeof(num) == $tint) {
		var res;
		res = integer_from_int(num);
		num_to_float(res);
	}
	else
		num_to_float(num);
}

base_number.new = function(num) {
	if($typeof(num) == $tint) {
		return num;
	}
	else if(is_num(num)) {
		if(integer_fits(num)) 
			return to_neko_num(num)
		else
			return num
	}
	else
		$throw(base_exception.argument_error("number.new", "number", num));
}

base_number.@stoi = function(str) {
	i_from_s(str);
}

base_number.@stof = function(str) {
	f_from_s(str);
}

base_number.@or@or = function(lhs, rhs) {
	base_object.@@true;
}

base_number.@and@and = function(lhs, rhs) {
	if(istrue(rhs))
		base_object.@@true
	else
		base_object.@@false
}

base_number.@greater = function(lhs, num) {
	if(base_number.@compare(lhs, num) == 1)
		base_object.@@true;
	else
		base_object.@@false;
}

base_number.@less = function(lhs, num) {
	if(base_number.@compare(lhs, num) == -1)
		base_object.@@true;
	else
		base_object.@@false;
}

base_number.@less@equal = function(lhs, num) {
	if(base_number.@compare(lhs, num) < 1)
		base_object.@@true;
	else
		base_object.@@false;
}

base_number.@greater@equal = function(lhs, num) {
	if(base_number.@compare(lhs, num) > -1)
		base_object.@@true;
	else
		base_object.@@false;
}

base_number.@plus = function(lhs, rhs) {
	var tlhs = $typeof(lhs);
	var trhs = $typeof(rhs);
	if(tlhs == $tint && trhs == $tint) {
		var res = $iadd(lhs, rhs);
		if(lhs >= 0 && rhs >= 0 && res >= lhs)
			res;
		else {
			lhs = integer_from_int(lhs);
			rhs = integer_from_int(rhs);
			base_number.new(num_add(lhs, rhs));
		}
	}
	else if((tlhs == $tint && is_num(rhs)) || (trhs == $tint && is_num(lhs)) || (is_num(rhs) && is_num(rhs))) {
		base_number.new(num_add(lhs, rhs));
	}
	else
		$throw(base_exception.argument_error("add", "number", $string(lhs) + " and " + $string(rhs)));
}

base_number.@minus = $varargs(function(args) {
	if($asize(args) == 1) {
		if($typeof(args[0]) == $tint)
			return 0 - args[0];
		else
			return num_neg(args[0]);
	}
	else if($asize(args) > 2)
		$throw(base_exception.argument_error("number -", "0 or 1", $asize(args)));
		
	lhs = args[0];
	rhs = args[1];
	var tlhs = $typeof(lhs);
	var trhs = $typeof(rhs);

	if(tlhs == $tint && trhs == $tint) {
		var res = $isub(lhs, rhs);
		if(lhs >= 0 && rhs >= 0 && res <= lhs)
			res;
		else if(lhs < 0 && rhs < 0 && res > lhs)
			res;
		else {
			lhs = integer_from_int(lhs);
			rhs = integer_from_int(rhs);
			base_number.new(num_sub(lhs, rhs));
		}
	}
	else if((tlhs == $tint && is_num(rhs)) || (trhs == $tint && is_num(lhs)) || (is_num(rhs) && is_num(rhs))) {
		base_number.new(num_sub(lhs, rhs));
	}
	else
		$throw(base_exception.argument_error("number.-", "number", $string(args[0]) + " and " + $string(args[1])));
})

base_number.@forward = function(lhs, rhs) {
	var tlhs = $typeof(lhs);
	var trhs = $typeof(rhs);

	if((tlhs == $tint && trhs == $tint) || (tlhs == $tint && is_num(rhs)) || (trhs == $tint && is_num(lhs)) || (is_num(rhs) && is_num(rhs)))
		base_number.new(num_div(lhs, rhs));
	else
		$throw(base_exception.argument_error("number./", "number", $string(lhs) + " and " + $string(rhs)));

}

base_number.@star = function(lhs, rhs) {
	var tlhs = $typeof(lhs);
	var trhs = $typeof(rhs);

	if(tlhs == $tint && trhs == $tint) {
		lhs = integer_from_int(lhs);
		base_number.new(num_mul(lhs, rhs));
	}
	else if((tlhs == $tint && is_num(rhs)) || (trhs == $tint && is_num(lhs)) || (is_num(rhs) && is_num(lhs))) {
		base_number.new(num_mul(lhs, rhs));
	}
	else
		$throw(base_exception.argument_error("number.*", "number", $string(lhs) + " and " + $string(rhs)));
}

base_number.@percent = function(lhs, rhs) {
	if($typeof(lhs) == $tint && $typeof(rhs) == $tint) {
		base_number.new(lhs % rhs);
	}
	else if(is_int(lhs) && is_int(rhs))
		base_number.new(int_mod(lhs, rhs));
	else
		$throw(base_exception.argument_error("number.%", "number", $string(lhs) + " and " + $string(rhs)));

}

base_number.@up = function(lhs, rhs) {
	base_number.new(int_pow(lhs,rhs));
}

base_number.@less@equal@greater = base_number.@compare;

base_number.@compare = function(lhs, rhs) {
	var tlhs = $typeof(lhs);
	var trhs = $typeof(rhs);

	if(tlhs == $tint && trhs == $tint)
		$pcompare(lhs,rhs);
	else if((tlhs == $tint && is_num(rhs)) || (trhs == $tint && is_num(lhs)) || (is_num(rhs) && is_num(rhs)))
		num_cmp(lhs, rhs);
	else
		$throw(base_exception.new("Cannot compare " + $string(lhs) + " and " + $string(rhs)));
}

base_number.@equal@equal = function(lhs, rhs) {
	if($pcompare(lhs, rhs) == 0)
		base_object.@@true;
	else if(($typeof(rhs) == $tint || is_num(rhs))) {
		if(base_number.@compare(lhs, rhs) == 0)
			base_object.@@true;
		else
			base_object.@@false;
	}
	else
		base_object.@@false;
}

base_number.@notequal = function(lhs, rhs) {
	base_object.not(base_number.@equal@equal(lhs, rhs))
}

base_number.times = function(lhs, block) {
	if($typeof(lhs) == $tint) {
		if(lhs == 0) return lhs;
		var index = 0;
	
		if($nargs(block) == 0) {
			while(index < lhs) {
				block();
				index = index + 1;
			}
		}
		else {
			while(index < lhs) {
				block(index);
				index = index + 1;
			}
		}
	}
	else
		$throw("Not implemented quite yet.");

	lhs;
}

base_number.to = function(lhs, stop, block) {
	if($typeof(lhs) == $tint) {
		var index = lhs;
		if(index == stop) return lhs;
	
		if(index < stop) {
			while(index <= stop) {
				block(index);
				index = index + 1;
			}
		}
		else {
			while(index >= stop) {
				block(index);
				index = index - 1;
			}
		}
	}
	else
		$throw("Not implemented quite yet.");

	lhs;
}

//Enumerable squishin
enumerable = new_brat(null);

enumerable.any@question = function(block) {
	if(this.@length == 0)
		return base_object.@@false;
	
	flag = base_object.@@false;

	var f = function(item) {
		if(flag == base_object.@@false && block(item) == base_object.@@true)
			flag = base_object.@@true;
			
	}

	this.each(f);

	flag;
}

enumerable.all@question = function(block) {
	if(this.@length == 0)
		return base_object.@@false;

	flag = base_object.@@true;

	var f = function(item) {
		if(flag == base_object.@@true && block(item) == base_object.@@false)
			flag = base_object.@@false;
			
	}

	this.each(f);

	flag;
}

enumerable.find = function(block) {
	if(this.@length == 0)
		return base_object.@@null;
	
	flag = base_object.@@null;

	var f = function(item) {
		if(flag == base_object.@@null && block(item) == base_object.@@true)
			flag = item;
			
	}

	this.each(f);

	flag;
}

enumerable.select = function(block) {
	if(this.@length == 0)
		return base_array.new();
	
	var new_ary = base_array.new();
	var f = function(item) {
		if(block(item) == base_object.@@true)
			new_ary.@less@less(item);
			
	}

	this.each(f);

	new_ary;
}

enumerable.to@underarray = function() {
	if(this.@length == 0)
		return base_array.new();
	
	var new_ary = base_array.new();
	var f = function(item) {
		new_ary.@less@less(item);
	}

	this.each(f);

	new_ary;
}

//Array object
base_array = new_brat(null);
base_array.@internal_array = $amake(0);

base_array.squish(enumerable);

base_array.new = $varargs(function(args) {
	var ary = new_brat(this);
	if($asize(args) > 0) {
		if($asize(args) == 1 && $typeof(args[0]) == $tarray)
			args = args[0];

		ary.@internal_array = args;
		ary.@length = $asize(args);
	}
	else {
		ary.@internal_array = $amake(16);
		ary.@length = 0;
	}
	ary;
});

base_array.@neko_array = function() { 
	if(this.@length == $asize(this.@internal_array))
		this.@internal_array
	else
		$asub(this.@internal_array, 0, this.@length);
}

base_array.length = function() {
	this.@length;
}

base_array.reserve = function(size) {
	if($typeof(size) != $tint)
		$throw(base_exception.argument_error("array.reserve", "integer", size));

	var empty = $asize(this.@internal_array) - this.@length;
	if(size > empty)
		this.@internal_array = $aconcat($array(this.@internal_array, $amake(size - empty)));

	this;
}

base_array.__get = $varargs(function(args) {
	var len = this.@length;
	if($asize(args) == 0 || $asize(args) > 2)
		$throw(base_exception.argument_error("array.get", "1 or 2", $asize(args)));
	else if($asize(args) == 1) {
		if($typeof(args[0] != $tint))
			$throw(base_exception.argument_error("array[]", "integer", args[0]));

		var index = args[0];

		if(index >= len || index < -len) {
			return base_object.@@null;
		}
		else if(index >= 0) {
			return this.@internal_array[index];
		}
		else { //index  < 0
			index = len + index;
			if(index < 0 || index >= len) {
				return base_object.@@null;
			}
			else {
				return this.@internal_array[index];
			}
		}
	}
	else {
		if($typeof(args[0]) != $tint)
			$throw(base_exception.argument_error("array[]", "integer", args[0]));

		if(len == 0) {
			this.new(); //return empty array
		}
		else {
			var start = args[0];
			var stop = args[1];

			if(start < 0)
				start = len + start;
			if(stop < 0)
				stop = len + stop;

			if(start < 0)
				start = 0;
			if(stop < 0)
				stop = 0;

			if(start > stop) {
				var temp = stop;
				stop = start;
				start = temp;
			}

			if(start >= len)
				return this.new();

			if(stop >= len)
				stop = len - 1;

			var new_array = $asub(this.@internal_array, start, stop - start + 1);
			base_array.new(new_array);
		}
	}
});

base_array.__set = function(index, value) {
	if($typeof(index) != $tint)
		$throw(base_exception.argument_error("array[]", "integer", args[0]));

	var len = this.@length;
	if(index < 0)
		index = len + index;

	if(index < 0)
		$throw(base_exception.new("Invalid array index: " + $string(index), "index error"));

	if(index >= len) {

		if(index < $asize(this.@internal_array)) { //no need to resize
			var i = this.@length;
			var n = base_object.@@null;
			while(i < index) {
				this.@internal_array[i] = n;
				i = i + 1;
			}
		}
		else {
			len = $asize(this.@internal_array);
			var new_array = $amake(index - len + 1);
			var i = 0;
			var n = base_object.@@null;
			var stop = index - len + 1;
			while( i < stop) {
				new_array[i] = n;
				i += 1;
			}

			i = this.@length;
			while(i < len) {
				this.@internal_array[i] = n;
			}

			this.@internal_array = $aconcat($array(this.@internal_array, new_array));
		}
	}

	this.@length = index + 1;
	this.@internal_array[index] = value;
	this;
}

base_array.push = function(value) {
	if(this.@length == $asize(this.@internal_array)) {	//resize
		var new_array = $amake((this.@length + 1) * 2);
		//this.@internal_array = $aconcat($array(this.@internal_array, new_array));
		$ablit(new_array, 0, this.@internal_array, 0, this.@length);
		this.@internal_array = new_array;
	}

	this.@internal_array[this.@length] = value;
	this.@length = this.@length + 1;

	this;
}

base_array.@less@less = base_array.push;

base_array.@plus = function(ary) {
	this.@internal_array = $aconcat($array(this.@neko_array(), ary.@neko_array()));
	this.@length = this.@length + ary.@length;
	this;
}

base_array.@equal@equal = function(rhs) {
	if($pcompare(this, rhs) == 0)
		base_object.@@true;
	else if($typeof(rhs) != $tobject || $not($objget(rhs, $hash("@neko_array")) != null))
		return base_object.@@false;

	var lhs = this.@internal_array;
	if(lhs == null) {
		$throw(base_exception.new($string(this) + " has a null array"));
	}
	else if(rhs.@internal_array == null) {
		$throw(base_exception.new("rhs has a null array"));
	}
	if(this.@length != rhs.@length)
		return base_object.@@false;

	rhs = rhs.@internal_array;
	var index = 0;
	var length = this.@length;
	while(index < length) {
		if($not(base_object.@check_equal(lhs[index], rhs[index])))
				return base_object.@@false

		index = index + 1;
	}
	base_object.@@true;
}

base_array.@to_s = function() {
	var i = 0;
	var len = this.@length;
	if(len == null) len = 0;
	var temp = $amake(len);
	while i < len {
		if($objget(this.@internal_array[i], $hash("@to_s")) != null)
			temp[i] = this.@internal_array[i].@to_s();
		else
			temp[i] = this.@internal_array[i];

		i += 1;
	}
	$string(temp);
}

base_array.reverse = function() {
	var index = 0;
	var length = this.@length;
	var new_array = $amake(length);

	while index < length + 1 {
		new_array[index] = this.@internal_array[length - index - 1];
		index = index + 1;
	}
	base_array.new(new_array);
}

base_array.reverse@bang = function() {
	var index = 0;
	var length = this.@length;
	var new_array = $amake(length);

	while index < length + 1 {
		new_array[index] = this.@internal_array[length - index - 1];
		index = index + 1;
	}

	this.@internal_array = new_array;
	this;
}

base_array.clear = function() {
	//this.@internal_array = $amake(0);
	this.@length = 0;
	this;
}

base_array.delete@underfirst = function(item) {
	var index = 0;
	var found = null;
	var length = this.@length;

	while index < length + 1 {
		if(base_object.@check_equal(item, this.@internal_array[index])) {
			found = index;
			break;
		}
		index = index + 1;
	}

	if(found != null) {
		if(found == this.@length - 1) {
			this.@internal_array[found] = null;
			this.@length = this.@length - 1;
		}
		else {
			var temp = $amake(length - 1);
			if(found > 0)
				$ablit(temp, 0, this.@internal_array, 0, found);

			if(found < length)
				$ablit(temp, found, this.@internal_array, found + 1, this.@length - found - 1);
	
			this.@internal_array = temp;
			this.@length = $asize(this.@internal_array);
		}
		this;
	}
	else
		this;
	
}

partition = function(array, left, right, pivot) {
	var pivot_value = array[pivot];
	if(($typeof(pivot_value) != $tobject || $not($objget(pivot_value, $hash("@greater@equal")) != null)) && $typeof(pivot_value) != $tint && $not(is_num(pivot_value)))
		$throw(base_exception.new("Cannot compare " + $string(pivot_value) + " in order to sort it."));
	var temp = array[pivot];
	array[pivot] = array[right];
	array[right] = temp;
	store_index = left;
	var i = left;

	var compare;

	if($typeof(pivot_value) == $tobject)
		compare = function(current) {
			pivot_value.@greater@equal(current) == base_object.@@true;
		}
	else if($typeof(pivot_value) == $tint || is_num(pivot_value))
		compare = function(current) {
			base_number.@greater@equal(pivot_value, current) == base_object.@@true;
		}
	else
		$throw(base_exception.new("Cannot compare " + $string(pivot_value) + " in order to sort it."));

	while(i < right) {
		if(compare(array[i])) {
			temp = array[store_index];
			array[store_index] = array[i];
			array[i] = temp;
			store_index = store_index + 1;
		}
		i = i + 1;
	}
	temp = array[store_index];
	array[store_index] = array[right];
	array[right] = temp;
	store_index;
}

quick_sort = function(array, left, right) {
	if(right > left) {
		var pivot = random_int(random(), right - left) + left;
		var new_pivot = partition(array, left, right, pivot);
		quick_sort(array, left, new_pivot - 1);
		quick_sort(array, new_pivot + 1, right);
	}
}

base_array.sort = function() {
	var array = $asub(this.@internal_array, 0, this.@length);
	quick_sort(array, 0, $asize(array) - 1);
	base_array.new(array);
}

base_array.sort@bang = function() {
	quick_sort(this.@internal_array, 0, this.@length - 1);
	this;
}

base_array.first = function() {
	this.get(0);
}

base_array.rest = function() {
	this.get(1, -1);
}

base_array.last = function() {
	this.get(-1);
}

base_array.map = function(block) {
	if(this.@length == 0)
		return base_array.new();

	var new_ary = base_array.new($amake(this.@length));
	new_ary.@length = this.@length;
	var index = 0;
	var length = this.@length;

	//Should be Brat String or function
	if($typeof(block) == $tobject) {
		var method = $hash(to_identifier(name));
		var args = $amake(0);
		while(index < length) {
			new_ary.@internal_array[index] = $objcall(this.@internal_array[index], method, args); 
			index = index + 1;
		}
	}
	else {	
		while(index < length) {
			new_ary.@internal_array[index] = block(this.@internal_array[index]);
			index = index + 1;
		}
	}

	new_ary;
}

base_array.map@underwith@underindex = function(block) {
	if(this.@length == 0)
		return base_array.new();

	var new_ary = base_array.new($amake(this.@length));
	new_ary.@length = this.@length;
	var index = 0;
	var length = this.@length;

	while(index < length) {
		new_ary.@internal_array[index] = block(this.@internal_array[index], index);
		index = index + 1;
	}

	new_ary;
}

base_array.each = function(block) {
	if(this.@length == 0)
		return this;;

	var index = 0;
	var length = this.@length;

	while(index < length) {
		block(this.@internal_array[index]);
		index = index + 1;
	}

	this;
}

base_array.each@underwith@underindex = function(block) {
	if(this.@length == 0)
		return this;;

	var index = 0;
	var length = this.@length;

	while(index < length) {
		block(this.@internal_array[index], index);
		index = index + 1;
	}

	this;
}

base_array.reverse@undereach = function(block) {
	if(this.@length == 0)
		return this;;

	var index = this.@length -1;

	while(index >= 0) {
		block(this.@internal_array[index]);
		index = index - 1;
	}

	this;
}

base_array.empty@question = function() {
	if(this.@length == 0)
		base_object.@@true;
	else
		base_object.@@false;
}

base_array.include@question = function(item) {
	if(this.@length == 0)
		return base_object.@@false;

	var index = 0;
	var length = this.@length;

	while(index < length) {
		if(base_object.@check_equal(this.@internal_array[index], item))
			return base_object.@@true;

		index = index + 1;
	}


	base_object.@@false;
}

base_array.index@underof = function(item) {
	if(this.@length == 0)
		return base_object.@@null;

	var index = 0;
	var length = this.@length;

	while(index < length) {
		if(base_object.@check_equal(this.@internal_array[index], item))
			return index;
		index = index + 1;
	}

	base_object.@@null;
}

base_array.index@underof = function(item) {
	if(this.@length == 0)
		return base_object.@@null;

	var index = this.@length - 1;

	while(index >= 0) {
		if(base_object.@check_equal(this.@internal_array[index], item))
			return index;

		index = index - 1;
	}

	base_object.@@null;
}

base_array.join = $varargs(function(args) {
	var arglen = $asize(args);
	var separator = ""
	if(arglen == 1) {
		separator = args[0];
		if($typeof(separator) == $tobject && $objget(separator, $hash("@neko_string")) != null)
			separator = separator.@value;

		if($typeof(separator) != $tstring)
			$throw(base_exception.argument_error("array.join", "string", separator));
	}
	else if(arglen != 0) {
		$throw(base_exception.argument_error("array.join", "0 or 1", arglen));
	}
	
	if(this.@length == 0)
		return base_string.new("");

	var index = 0;
	var length = this.@length - 1;
	var cur;
	var result = "";

	while(index < length) {
		cur = this.@internal_array[index];

		if($typeof(cur) == $tabstract && is_num(cur))
			cur = base_number.to@unders(cur);
		else if($typeof(cur) != $tstring)
			cur = $string(cur);

		result = result + cur + separator;
		index = index + 1;
	}

	cur = this.@internal_array[length];
	if($typeof(cur) == $tabstract && is_num(cur))
		cur = base_number.to@unders(cur);
	else if($typeof(cur) != $tstring)
		cur = $string(cur);

	base_string.new(result + cur);
})

base_array.to@underarray = function() { this }

base_array.set = base_array.__set;
base_array.get = base_array.__get;

//Hash table object
base_hash = new_brat(null);
base_hash.@internal_hash = $hnew(10);
base_hash.@compare = function(lhs, rhs) {
	if($typeof(lhs) == $tobject && $typeof(rhs) == $tobject) {
		if(istrue(lhs.@equal@equal(rhs)))
			0
		else
			-1
	}
	else if($typeof(lhs) == $tint || is_num(lhs)) {
		if(istrue(base_number.@equal@equal(lhs, rhs)))
			0
		else
			-1
	}
	else 
		$compare(lhs, rhs);
}

base_hash.new = $varargs(function(args) {
	var hsh = new_brat(this);
	if($asize(args) == 0) {
		hsh.@internal_hash = $hnew(1);
	}
	else if($typeof(args[0]) == $tabstract) {
		hsh.@internal_hash = args[0];
	}
	else {
		$throw(base_exception.new("Invalid hash initialization:" + $string(args)));
	}
	hsh;
});

base_hash.get = function(index) {
	if($hmem(this.@internal_hash, index, base_hash.@compare) == true)
		$hget(this.@internal_hash, index, base_hash.@compare);
	else
		base_object.@@null;
}

base_hash.set = function(index, value) {
	$hset(this.@internal_hash, index, value, base_hash.@compare);
	this;
}

base_hash.__set = base_hash.set;
base_hash.__get = base_hash.get;

make_hash = function(neko_hash) {
	var hsh = base_hash.new();
	hsh.@internal_hash = neko_hash;
	hsh;
}

base_hash.key@question = function(index) {
	if($hmem(this.@internal_hash, index, base_hash.@compare))
		base_object.@@true;
	else
		base_object.@@false;
}

base_hash.each = function(block) {
	$hiter(this.@internal_hash, block);
	this;
}

base_hash.each@underkey = function(block) {
	var f = function(k,v) {
		block(k);
	}

	$hiter(this.@internal_hash, f);
	this;
}

base_hash.each@undervalue = function(block) {
	var f = function(k,v) {
		block(v);
	}

	$hiter(this.@internal_hash, f);
	this;
}

base_hash.delete = function(key) {
	$hremove(this.@internal_hash, key, base_hash.@compare);
	this;
}

base_hash.length = function() {
	$hcount(this.@internal_hash);
}

base_hash.select = function(block) {
	var res = $hnew(5);
	var test = function(key, value) { 
		if(istrue(block(key, value)))
			$hset(res, key, value, base_hash.@compare);
	}
	$hiter(this.@internal_hash, test);
	make_hash(res);
}

base_hash.map = function(block) {
	var res = $amake($hcount(this.@internal_hash));
	var i = 0;
	var fun = function(key, value) {
		res[i] = block(key, value);
		i = i + 1;
	}

	$hiter(this.@internal_hash, fun);
	base_array.new(res);
}

base_hash.keys = function() {
	var fun = function(key, value) {
		key;
	}
	this.map(fun);
}

base_hash.empty@question = function() {
	if($hcount(this.@internal_hash) == 0)
		base_object.@@true;
	else
		base_object.@@false;
}

base_hash.@plus = function(rhs) {
	if($typeof(rhs) != $tabstract || $objget(rhs, $hash("@internal_hash")) != null)
		base_exception.argument_error("hash.+", "hash", rhs);
	
	rhs = rhs.@internal_hash;
	var lhs = this.@internal_hash;
	var res = $hnew($hcount(lhs) + $hcount(rhs));
	var f = function(key, value) {
		$hset(res, key, value, base_hash.@compare);	
	}

	$hiter(lhs, f);
	$hiter(rhs, f);
	base_hash.new(res);
}

base_hash.@to_s = function() {
	output = "{";
	var st = function(k,v) {
		if($typeof(k) == $tabstract && is_num(k))
			k = base_number.to@unders(k);

		if($typeof(v) == $tabstract && is_num(v))
			v = base_number.to@unders(v);
		
		output = output + $string(k) + " : " + $string(v) + ", ";
	}

	$hiter(this.@internal_hash, st);

	var s = $ssize(output);
	if(s > 1)
		$ssub(output, 0, s - 2) + "}";
	else
		output + "}";
}

hset = function(hashtable, index, value) {
	$hset(hashtable, index, value, base_hash.@compare)
}


base_string = new_brat(null);

base_string.squish(comparable);

base_string.@value = "";
base_string.@to_s = function() {
	this.@value;
}

base_string.@string = function(val) {
	if($typeof(val) == $tabstract && is_num(val))
		base_number.@to_s(val);
	else
		$string(val);
}

base_string.@neko_string = function() { this.@value }

base_string.to@unders = function() { this }

base_string.@equal@equal = function(rhs) {
	if($pcompare(this, rhs) == 0)
		base_object.@@true;
	else if($typeof(rhs) == $tobject && $objget(rhs, $hash("@neko_string")) != null) {
		if($compare(this.@neko_string(), rhs.@neko_string()) == 0)
			base_object.@@true;
		else
			base_object.@@false;
	}
	else
		base_object.@@false;
}

base_string.@less@equal@greater = function(rhs) {
	if($typeof(rhs) == $tobject && $objget(rhs, $hash("@neko_string")) != null) {
		$compare(this.@neko_string(), rhs.@neko_string());
	}
	else
		$throw(base_exception.new("Cannot compare " + $string(this) + " and " + $string(rhs)));
}

base_string.to@underi = function() {
	var ts = this.sub(base_regex.new("\\.\\d*$"), "");
	base_number.new(i_from_s(ts.@value));
}

base_string.to@underf = function() {
	base_number.new(f_from_s(this.@value));
}

base_string.length = function() {
	this.@length;
}

base_string.new = $varargs(function(args) {
	var s = new_brat(this);
	if($asize(args) == 0) {
		s.@value = "";
	}
	else if($asize(args) == 1) {
		if($typeof(args[0]) == $tstring) {
			s.@value = args[0];
		}
		else if($typeof(args[0]) == $tobject && $objget(args[0], $hash("@neko_string")) != null) {
			s.@value = $scopy(args[0].@value);
		}
		else if($typeof(args[0]) != $tobject) 
			s.@value = $string(args[0]);
		else
			$throw(base_exception.argument_error("string.new", "string", args[0]));
	}
	else
		$throw(base_exception.argument_error("string.new", "0 or 1", $asize(args)));

	s.@length = $ssize(s.@value);
	s;
});

base_string.__get = $varargs(function(args) {
	var len = $ssize(this.@value);
	if($asize(args) == 0 || $asize(args) > 2)
		$throw(base_exception.argument_error("string.get", "1 or 2", $asize(args)));
	else if($asize(args) == 1) {
		if($typeof(args[0]) != $tint)
			$throw(base_exception.new("Cannot index string with non-integer value."));

		var index = args[0];
		if(index >= len || index < -len) {
			this.new("");
		}
		else if(index >= 0) {
			var new_string = $ssub(this.@value, index, 1);
			return this.new(new_string);
		}
		else { //index  < 0
			index = len + index;
			if(index < 0 || index >= len) {
				this.new("");
			}
			else {
				var new_string = $ssub(this.@value, index, 1);
				this.new(new_string);
			}
		}
	}
	else {
		if($typeof(args[0]) != $tint || $typeof(args[1] != $tint))
			$throw(base_exception.new("Cannot index string with non-integer value."));
		if(len == 0) {
			this.new("");
		}
		else {
			var start = args[0];
			var stop = args[1];
			if(start < 0)
				start = len + start;
			if(stop < 0)
				stop = len + stop;

			if(start < 0)
				start = 0;
			if(stop < 0)
				stop = 0;

			if(start > stop) {
				var temp = stop;
				stop = start;
				start = temp;
			}

			if(start >= len)
				return this.new("");

			if(stop >= len)
				stop = len - 1;

			var new_string = $ssub(this.@value, start, stop - start + 1);
			this.new(new_string);
		}		
	}
})

base_string.__set = function(index, value) {
	if($typeof(value) == $tobject && $objget(value, $hash("@neko_string")) != null)
		value = $string(value.@value);
	if($typeof(value) != $tstring)
		$throw("Cannot set string to non-string value.");


	if($typeof(index) != $tint)
		$throw("Cannot use non-integer index for string.");

	if(index < 0)
		index = $ssize(this.@value) + index;

	if(index < 0 || index >= $ssize(this.@value))
		$throw("Invalid string index: " + $string(index) + " when string is " + $string($ssize(this.@value)) + " long.")

			$sblit(this.@value, index, value, 0, $ssize(value));
	this;
}

base_string.@less@less = function(value) {
	if($typeof(value) == $tobject && $objget(value, $hash("@neko_string")) != null)
		value = $string(value.@value);
	if($typeof(value) != $tstring)
		$throw("Cannot add string to non-string value.");

	var new_string = this.@value + value;

	this.@value = new_string;
	this.@length = $ssize(new_string);
	this;
}

base_string.@plus = function(value) {
	if($typeof(value) == $tobject && $objget(value, $hash("@neko_string")) != null)
		value = $string(value.@value);
	if($typeof(value) != $tstring)
		$throw("Cannot add string to non-string value.");

	var new_string = this.@value + value;
	base_string.new(new_string);
}

base_string.@star = function(value) {
	if($typeof(value) != $tint)
		$throw(base_exception.argument_error("string.*", "integer", value));

	var new_str = "";
	var my_string = this.@value;
	while(value > 0) {
		new_str += my_string;
		value -= 1;
	}

	base_string.new(new_str);
}

base_string.index@underof = function(value) {
	if($typeof(value) == $tobject && $objget(value, $hash("@neko_string")) != null)
		value = $string(value.@value);
	if($typeof(value) != $tstring)
		$throw(base_exception.argument_error("string.index_of", "string", value));

	var index = $sfind(this.@value, 0, value);		

	if(index == null)
		base_object.@@null;
	else
		index;
}

reg_rep_first = $loader.loadprim("regexp@regexp_replace", 3);
reg_rep = $loader.loadprim("regexp@regexp_replace_all", 3);
reg_rep_fun = $loader.loadprim("regexp@regexp_replace_fun", 3);
reg_match = $loader.loadprim("regexp@regexp_matched", 2);
reg_matched = function(regex) { reg_match(regex, 0) }
base_string.sub = function(regexp, replacement) {
	if($typeof(regexp) == $tobject && $objget(regexp, $hash("@internal_regex")) != null)
		regexp = regexp.@internal_regex;
	if($typeof(replacement) == $tobject && $objget(replacement, $hash("@neko_string")) != null)
		replacement = replacement.@value;
	if($typeof(regexp) != $tabstract)
		$throw("Need to provide a regular expression for string.sub()");
	var new_string;
	if($typeof(replacement) == $tstring) {
		new_string = reg_rep(regexp, this.@value, replacement);
	}
	else if($typeof(replacement) == $tfunction) {
		var f = function(m) { replacement(base_string.new(reg_matched(m))) };
		new_string = reg_rep_fun(regexp, this.@value, f);
	}
	else $throw("Need to provide a string or function for string.sub()");

	base_string.new(new_string);
}

base_string.sub@bang = function(regexp, replacement) {
	if($typeof(regexp) == $tobject && $objget(regexp, $hash("@internal_regex")) != null)
		regexp = regexp.@internal_regex;
	if($typeof(replacement) == $tobject && $objget(replacement, $hash("@neko_string")) != null)
		replacement = replacement.@value;
	if($typeof(regexp) != $tabstract)
		$throw("Need to provide a regular expression for string.sub()");
	if($typeof(replacement) == $tstring) {
		this.@value = reg_rep(regexp, this.@value, replacement);
	}
	else if($typeof(replacement) == $tfunction) {
		var f = function(m) { replacement(base_string.new(reg_matched(m))) };
		this.@value = reg_rep_fun(regexp, this.@value, f);
	}
	else $throw("Need to provide a string or function for string.sub()");

	this.@length = $ssize(this.@value);
	this;
}

base_string.sub@underfirst@bang = function(regexp, replacement) {
	if($typeof(regexp) == $tobject && $objget(regexp, $hash("@internal_regex")) != null)
		regexp = regexp.@internal_regex;
	if($typeof(replacement) == $tobject && $objget(replacement, $hash("@neko_string")) != null)
		replacement = replacement.@value;
	if($typeof(regexp) != $tabstract)
		$throw("Need to provide a regular expression for string.sub_first()");
	if($typeof(replacement) == $tstring)
		this.@value = reg_rep_first(regexp, this.@value, replacement);
	else $throw("Need to provide a string for string.sub_first()");

	this.@length = $ssize(this.@value);

	this;
}

base_string.sub@underfirst = function(regexp, replacement) {
	if($typeof(regexp) == $tobject && $objget(regexp, $hash("@internal_regex")) != null)
		regexp = regexp.@internal_regex;
	if($typeof(replacement) == $tobject && $objget(replacement, $hash("@neko_string")) != null)
		replacement = replacement.@value;
	if($typeof(regexp) != $tabstract)
		$throw("Need to provide a regular expression for string.sub_first()");
	if($typeof(replacement) == $tstring) {
		base_string.new(reg_rep_first(regexp, this.@value, replacement));
	}
	else $throw("Need to provide a string for string.sub_first()");
}

string_split = $loader.loadprim("std@string_split", 2);

base_string.split = $varargs(function(args) {
		var sep;
		var arglen = $asize(args);
		if(arglen == 0)
		sep = " ";
		else if(arglen == 1) {
		sep = args[0];
		if($typeof(sep) == $tobject && $objget(sep, $hash("@neko_string")) != null)
		sep = sep.@value;
		if($typeof(sep) != $tstring)
		$throw("Separator for split() must be a string, not " + $string(sep));
		}
		else
		$throw("Expected 0 or 1 arguments for string.split.");

		if($ssize(sep) == 0)
		return this.dice();

		var first = $new(null);
		var list = first;
		var pos = 0;
		var strlen = $ssize(this.@value);
		var temp = this.@value;
		var match_pos = 0;
		var sep_len = $ssize(sep);
		var matches = 0;
		while(pos < strlen) {
			match_pos = $sfind(temp, pos, sep);
			if(match_pos != null) {
				list.data = base_string.new($ssub(temp, pos, match_pos - pos));
				pos = match_pos + sep_len;
			}
			else {
				list.data = base_string.new($ssub(temp, pos, strlen - pos));
				pos = strlen;
			}
			matches = matches + 1;
			list.next = $new(null);	
			list = list.next;
		}

		var i = 0;
		var res = $amake(matches);
		list = first;
		while(i < matches) {
			res[i] = list.data;
			list = list.next;
			i = i + 1;
		}

		base_array.new(res);
})

base_string.dice = function() {
	var i = 0;
	var strlen = $ssize(this.@value);
	var res = $amake(strlen);
	while(i < strlen) {
		res[i] = this.__get(i);
		i = i + 1;
	}

	base_array.new(res);
}

string_url_encode = $loader.loadprim("std@url_encode", 1);
string_url_decode = $loader.loadprim("std@url_decode", 1);

base_string.url@underencode = function() {
	base_string.new(string_url_encode(this.@value));	
}

base_string.url@underdecode = function() {
	base_string.new(string_url_decode(this.@value));	
}

regexp_new = $loader.loadprim("regexp@regexp_new", 1);
base_regex = new_brat(null);
base_regex.@internal_regex = base_object.@@null;
base_regex.new = function(regx_string) {
	if($typeof(regx_string) == $tobject && $objget(regx_string, $hash("@neko_string")) != null)
		regx_string = regx_string.@value;
	if($typeof(regx_string) != $tstring)
		$throw("Must create new regex with a string, not " + $string(regx_string));

	var reg = new_brat(this);
	reg.@internal_regex = regexp_new(regx_string);
	reg; 
}

regexp_match = $loader.loadprim("regexp@regexp_match", 4);
base_regex.match = function(val) {
	if($typeof(val) == $tobject && $objget(val, $hash("@neko_string")) != null)
		val = val.@value;
	else
		$throw("Wrong, wrong, wrong!");

	if(regexp_match(this.@internal_regex, val, 0, $ssize(val)))
		base_object.@@true;
	else
		base_object.@@false;
}

base_regex.@tilde = base_regex.match;

base_symbol = new_brat(null);
base_symbol.new = function(sym_string) {
	if($typeof(sym_string) == $tobject && $objget(sym_string, $hash("@neko_string")) != null)
		sym_string = sym_string.@neko_string();
	else if($typeof(sym_string) == $tstring)
		sym_string = $hash(sym_string);
	else if($typeof(sym_string) == $tint) { 
		//assume it comes directly from $hash() in parser
	}
	else
		$throw("Must create new symbol with using a string or a symbol, not " + $string(sym_string));

	var sym = new_brat(this);
	sym.@sym_value = sym_string;
	sym; 
}

base_symbol.@equal@equal = function(rhs) {
	if($pcompare(this, rhs) == 0)
		base_object.@@true;
	else if($typeof(rhs) == $tobject && $objget(rhs, $hash("@sym_value")) != null)
		rhs = rhs.@sym_value;

	if($pcompare(this.@sym_value, rhs) == 0)
		base_object.@@true;
	else
		base_object.@@false;
}

base_symbol.@to_s = function() {
	$field(this.@sym_value);
}

base_symbol.@to_identifier = function() {
	if(this.@identifier != null)
		this.@identifier;
	else
		this.@identifier = to_identifier($field(this.@sym_value));

	this.@identifier;
}

to_id_list = $hnew(22);
$hset(to_id_list, "!", "@bang", null)
$hset(to_id_list, "*", "@star", null)
$hset(to_id_list, "-", "@minus", null)
$hset(to_id_list, "+", "@plus", null)
$hset(to_id_list, "||", "@oror", null)
$hset(to_id_list, "|",  "@or", null)
$hset(to_id_list, "&&", "@andand", null)
$hset(to_id_list, "&", "@and", null)
$hset(to_id_list, "@", "@at", null)
$hset(to_id_list, "~", "@tilde", null)
$hset(to_id_list, "^", "@up", null)
$hset(to_id_list, "/", "@forward", null)
$hset(to_id_list, "\\", "@back", null)
$hset(to_id_list, "?", "@question", null)
$hset(to_id_list, "<", "@less", null)
$hset(to_id_list, ">", "@greater", null)
$hset(to_id_list, "!=","@notequal", null)
$hset(to_id_list, "=", "@equal", null)
$hset(to_id_list, ">=", "@greater@equal", null)
$hset(to_id_list, "<=", "@less@equal", null)
$hset(to_id_list, "%", "@percent", null)
$hset(to_id_list, "_", "@under", null)
$hset(to_id_list, "$", "@dollar", null)

from_id_list = $hnew(22);
$hset(from_id_list, "@bang", "!", null)
$hset(from_id_list, "@star", "*", null)
$hset(from_id_list, "@minus", "-", null)
$hset(from_id_list, "@plus", "+", null)
$hset(from_id_list, "@oror", "||", null)
$hset(from_id_list, "@or",  "|", null)
$hset(from_id_list, "@andand", "&&", null)
$hset(from_id_list, "@and", "&", null)
$hset(from_id_list, "@at", "@", null)
$hset(from_id_list, "@tilde", "~", null)
$hset(from_id_list, "@up", "^", null)
$hset(from_id_list, "@forward", "/", null)
$hset(from_id_list, "@back", "\\", null)
$hset(from_id_list, "@question", "?", null)
$hset(from_id_list, "@less", "<", null)
$hset(from_id_list, "@greater", ">", null)
$hset(from_id_list, "@notequal","!=", null)
$hset(from_id_list, "@equal", "=", null)
$hset(from_id_list, "@percent", "%", null)
$hset(from_id_list, "@under", "_", null)
$hset(from_id_list, "@dollar", "$", null)

to_id_regexp_symbols = regexp_new("!=|>=|<=|\\|\\||[!?\\-*+^@~\\/\\\\><$_%|&=]"); 
to_id_regexp_keywords = regexp_new("\\b(true|false|if|then|else|do|while|break|continue|switch|default|null|var|try|catch|return|function|this)\\b");
to_identifier = function(string) {
	if($typeof(string) == $tobject) {
		if($objget(string, $hash("@neko_string")) != null) {
			string = string.@neko_string();
		}
		else if($objget(string, $hash("@sym_value")) != null) {
			return string.@to_identifier();
		}
	}
	if($typeof(string) != $tstring)
		$throw("Cannot convert " + $string(string) + " to an identifier.");

	var f1 = function(m) { $hget(to_id_list, reg_matched(m), null) };
	string = reg_rep_fun(to_id_regexp_symbols, string, f1);
	var f2 = function(m) { "@" + reg_matched(m) }
	reg_rep_fun(to_id_regexp_keywords, string, f2);
}

from_id_regexp_symbols = regexp_new("@(bang|star|minus|plus|oror|or|andand|and|at|tilde|up|forward|back|question|less|greater|notequal|equal|percent|under|dollar)");
from_id_regexp_keywords = regexp_new("@(true|false|if|then|else|do|while|break|continue|switch|default|null|var|try|catch|return|function|this)");
from_identifier = function(string) {
	if($typeof(string) != $tstring)
		$throw("Cannot convert " + $string(string) + " to an identifier.");


	var f1 = function(m) { $hget(from_id_list, reg_matched(m), null) };
	string = reg_rep_fun(from_id_regexp_symbols, string, f1);
	var f2 = function(m) { var s = reg_matched(m); $ssub(s, 1, $ssize(s) - 1); }
	reg_rep_fun(from_id_regexp_keywords, string, f2);
}

run_gc = $loader.loadprim("std@run_gc", 1);
gc_stats = $loader.loadprim("std@gc_stats", 0);

base_object.memstats = function() {
	$print("Before running gc:", gc_stats(), "\n");
	run_gc(true);
	$print("After running gc:", gc_stats(), "\n");
}

convert_stack = function(array) {
	var index = 0;
	var stop = $asize(array) - 1; //skip last, that's us catching it
	var stack = $amake(stop);
	var current = null;

	while(index < stop) {
		current = array[index];
		if(current == null)
			stack[index] = base_object.@@null;
		else if($typeof(current) == $tstring)
			stack[index] = base_string.new(current);
		else if($typeof(current) == $tarray)
			stack[index] = base_array.new($array(base_string.new($string(current[0])), base_string.new($string(current[1]))));
		else
			stack[index] = current;

		index = index + 1;
	}

	base_array.new(stack);
}

base_object.protect = $varargs(function(args) {
	var arglen = $asize(args);
	var block;
	var options;

	if(arglen < 1)
		$throw(base_exception.argument_error("protect", "at least one argument", "0"));
	else if(arglen == 1) {
		if($typeof(args[0]) != $tfunction)
			$throw(base_exception.argument_error("protect", "block argument", args[0]));

		block = args[0];			
	}
	else if(arglen == 2) {
		if($typeof(args[0]) != $tfunction)
			$throw(base_exception.argument_error("protect", "block argument as first argument", args[0]));
	
		block = args[0];

		if($typeof(args[1]) != $tobject || $objget(args[1], $hash("@internal_hash")) == null)
			$throw(base_exception.argument_error("protect", "hash object as second argument", args[1]));

		options = args[1];
	}
	else
		$throw(base_exception.argument_error("protect", "at most two arguments", arglen));
		
	try {
		block();
	}
	catch e {
		if(options != null) {
			var rescue = base_symbol.new("rescue");

			if($typeof(e) == $tstring)
				e = base_exception.new(e);

			var stack = convert_stack($callstack());
			e.stack@undertrace = function() { stack };

			if($typeof(options) == $tobject && istrue(options.key@question(rescue))) {
				var rescue_block = options.get(rescue);
				if($typeof(rescue_block) == $tfunction) {
					if($nargs(rescue_block) == 0)
						rescue_block();
					else
						rescue_block(e);
				}
				else
					$throw(base_exception.argument_error("rescue", "block", rescue_block));
			}
		}
	}
})

base_object.throw = function(exception) {
	if($typeof(exception) != $tobject || $objget(exception, $hash("stack@undertrace")) == null)
		exception = base_exception.new(exception);

	$throw(exception);
}

base_exception = new_brat(null);
base_exception.new = $varargs(function(args) {
	var arg_len = $asize(args);
	var error_message;
	var type = "standard error";

	if(arg_len == 0) {
		error_message = "Unspecified exception";
	}
	else if(arg_len == 1) {
		error_message = args[0];
	}
	else if(arg_len == 2) {
		error_message = args[0];
		type = args[1];
	}
	else {
		$throw(base_exception.argument_error("base_exception.new", "1 or 2", arg_len))
	}

	if($typeof(error_message) == $tstring)
		error_message = base_string.new(error_message);
	else
		error_message = base_string.new($string(error_message)); 

	if($typeof(type) == $tstring)
		type = base_string.new(type);
	else if($typeof(type) != $tobject || $objget(type, $hash("@neko_string")) == null)
		$throw(base_exception.argument_error("base_exception.new", "string", type));

	var e = new_brat(this);
	e.error@undermessage = function() { error_message };
	e.type = function() { type };
	var stack = convert_stack($callstack());
	e.stack@undertrace = function() { stack };
	e;
})

base_exception.@to_s = function() {
	if($objget(this, $hash("error@undermessage")) == null)
		"Uninitialized exception"
	else
		$string(this.error@undermessage()) + "\nBacktrace:\n" + $string(this.stack@undertrace())
}

base_exception.argument_error = function(name, expected, given) {
	this.new("Argument error: " + $string(name) + " expected " + $string(expected) + " argument(s) but was given " + $string(given) + ".", "argument error");
}

base_exception.argument@undererror = base_exception.argument_error;

base_exception.convert_error = function(current, to) {
	this.new("Conversion error: Cannot convert " + $string(current) + " to " + $string(to) + ".", "convert error");
}

base_exception.convert@undererror = base_exception.convert_error;

base_exception.method_error = function(object, name) {
	this.new("Method error: " + $string(object) + " has no method called '" + $string(name) + "'.", "method error");
}

base_exception.method@undererror = base_exception.method_error;

base_exception.null_error = function(name, cannot) {
	this.new("Null error: " + $string(name) + " is null, cannot " + $string(cannot) + ".", "null error");
}

base_exception.@null@undererror = base_exception.null_error;

base_exception.name_error = function(name) {
	this.new("Name error: No such method or local variable '" + $string(name) + "'.", "name error");
}

base_exception.name@undererror = base_exception.name_error;

$exports.hset = hset;
$exports.make_hash = make_hash;
$exports.new_brat = new_brat;
$exports.has_field = has_field;
$exports.base_array = base_array;
$exports.base_hash = base_hash;
$exports.base_number = base_number;
$exports.base_string = base_string;
$exports.base_object = base_object;
$exports.base_regex = base_regex;
$exports.base_symbol = base_symbol;
$exports.base_exception = base_exception;
$exports.memstats = memstats;
$exports.nice_identifier = from_identifier;
$exports.to_identifier = to_identifier;
$exports.comparable = comparable;
$exports.enumerable = enumerable;
$exports.brat_var_args = $loader.loadprim("core-util@brat_var_args", 1);
$exports.is_num = is_num;
