base_object = $new(null);

base_object.new = $varargs(function(args) {
	var arg_hash;
	if($asize(args) > 0 ) {
		arg_hash = args[0];

		if($typeof(arg_hash) == $tobject && has_field(arg_hash, "@internal_hash")) {
			arg_hash = arg_hash.@internal_hash; 
		}
	}
	else
		arg_hash = $hnew(0);


	if($typeof(arg_hash) != $tabstract)
		$throw("Expecting hash table for initialization.");

	new_brat(this, arg_hash);
})

//Create a new object with either parent_brat or base_object
//as the parent class.
new_brat = function(parent_brat, arg_hash) {
	var brat = $new(null);

	if(parent_brat == null) {
		$objsetproto(brat, base_object);
	}
	else 
	{
		$objsetproto(brat, parent_brat);
	}

	if(arg_hash != null && $hcount(arg_hash) > 0) {
		var set_f = function(k,v) {
			if($typeof(v) != $tfunction)
				v = function() { v };
			if($typeof(k) == $tint)
				$objset(brat, k, v);
			else if($typeof(k) == $tstring)
				$objset(brat, $hash(k), v);
			else
				$throw("Expecting symbol or string for field name.");
		}

		$hiter(arg_hash, set_f);
	}

	brat;
}

base_object.clone = function() {
	var brat = $new(this);
	$objsetproto(brat, $objgetproto(this));
	brat;
}

base_object.my = function() {
	return this;
}

base_object.to@unders = function() {
	var fields = $objfields(this);
	var index = 0;
	var length = $asize(fields);
	var vals = $hnew(length);
	var cur_field;
	var output = "#object {"
	while index < length {
		cur_field = fields[index];
		output = output + " " + $field(cur_field);
		index = index + 1;
	} 
	base_string.new(output + " }");
}

base_object.@to_s = function() {
	this.to@unders().@value;
}

base_object.__string = function() {
	this.@to_s();
};

base_object.print = $varargs(function(args) {
	var i = 0;
	var len = $asize(args);
	while i < len {
		if(has_field(args[i], "@to_s")) {
			args[i] = args[i].@to_s();
		};
		i += 1;
	};
	$call($print, null, args);
	base_object.@null();
})

base_object.p = $varargs(function(args) {
	var pargs = $aconcat($array(args, $array("\n")));
	$call(this.print, null, pargs);
})

base_object.squish = function(object) {
	if($typeof(object) != $tobject)
		$throw("Can only squish in objects.");

	var fields = $objfields(object);
	var num_fields = $asize(fields);
	var i = 0;
	while( i < num_fields) {
		var fval = $objget(object, fields[i]);
		if($typeof(fval) == $tfunction) {
			$objset(this, fields[i], fval);
		}
		i = i + 1;
	}
	this;
}

var random = $loader.loadprim("std@random_new", 0);
var random_int = $loader.loadprim("std@random_int", 2);
base_object.random = function(x) {
	var max ;
	if($typeof(x) == $tobject && has_field(x, "@value")) {
		max = x.@value;
		if($typeof(max) == $tint)
			base_number.new(random_int(random(), max));
		else
			$throw("Expected integer, got " + $string(max));
	}
	else
		$throw("Expected number, got " + $string(x));
}

var stdin = $loader.loadprim("std@file_stdin", 0);
var read_char = $loader.loadprim("std@file_read_char", 1);
var buffer_new = $loader.loadprim("std@buffer_new", 0);
var buffer_add_char = $loader.loadprim("std@buffer_add_char", 2);
var buffer_string = $loader.loadprim("std@buffer_string", 1);
base_object.g = $varargs(function(args) {
	var break_char = 10;
	if($asize(args) == 1) {
		if($typeof(args[0]) == $tobject && has_field(args[0], "@value") && $ssize(args[0].@value) == 1)
			break_char = $sget(args[0].@value, 0)
		else
			$throw("g expects to get a single character. Not " + $string(args[0]));
	}
	else if($asize(args) > 1) {
		$throw("Wrong number of arguments: g expects 0 or 1 but you gave it " + $string($asize(args)));
	}

        var b = buffer_new();
	var in = stdin();
	try {
        	do {
        		var c = read_char(in);
	                if(c == break_char)
	                        break;
		        buffer_add_char(b,c);
	        } while(true);
	}
	catch e {
		return base_object.@null();
	}
        base_string.new(buffer_string(b));
})

var @false_value = new_brat(null, null);
@false_value.to@unders = function() { base_string.new("false") };
var @true_value = new_brat(null, null);
@true_value.to@unders = function() { base_string.new("true") };
var @null_value = new_brat(null, null);
@null_value.to@unders = function() { base_string.new("null") };
base_object.@false = function() { @false_value }
base_object.@true = function() { @true_value }
base_object.@null = function() { @null_value}

base_object.@equal@equal = function(rhs) {
	var lhs = this;
	if(has_field(rhs, "@value") && has_field(lhs, "@value")) {
		rhs = rhs.@value;
		lhs = lhs.@value;
	}

	if($compare(lhs,rhs) == 0)
		this.@true();
	else
		this.@false();
}

var istrue = function(arg) {
	if(arg == base_object.@null() || arg == base_object.@false()) {
		false;
	}
	else {
		true;
	}
}

base_object.@0_@true@question = function() {
	if(istrue(this))
		base_object.@true();
	else
		base_object.@false();
	
}

base_object.@1_@true@question = function(condition) {
	var first;
	if($typeof(condition) == $tfunction) {
		first = condition();
	}
	else {
		first = condition
	}

	if(istrue(first))
		base_object.@true();
	else
		base_object.@false();
}


base_object.@2_@true@question = function(condition, true_branch) {
	var first;
	if($typeof(condition) == $tfunction) {
		first = condition();
	}
	else {
		first = condition
	}

	if(istrue(first)) {
		if($typeof(true_branch) == $tfunction) {
			true_branch();
		}
		else {
			true_branch;
		}
	}
	else {
		first;
	}
}


base_object.@3_@true@question = function(condition, true_branch, false_branch) {
	var first;
	if($typeof(condition) == $tfunction) {
		first = condition();
	}
	else {
		first = condition
	}

	if(istrue(first)) {
		if($typeof(true_branch) == $tfunction) {
			true_branch();
		}
		else {
			true_branch;
		}
	}
	else {
		if($typeof(false_branch) == $tfunction) {
			false_branch();
		}
		else {
			false_branch;
		}
	}
}

base_object.@0_@false@question = function() {
	if($not(istrue(this)))
		base_object.@true();
	else
		base_object.@false();
}

base_object.@1_@false@question = function(condition) {
	var first;
	if($typeof(condition) == $tfunction) {
		first = condition();
	}
	else {
		first = condition
	}

	if($not(istrue(first)))
		base_object.@true();
	else
		base_object.@false();
}


base_object.@2_@false@question = function(condition, false_branch) {
	var first;
	if($typeof(condition) == $tfunction) {
		first = condition();
	}
	else {
		first = condition
	}

	if($not(istrue(first))) {
		if($typeof(false_branch) == $tfunction) {
			false_branch();
		}
		else {
			false_branch;
		}
	}
	else {
		first;
	}
}

base_object.@3_@false@question = function(condition, false_branch, true_branch) {
	var first;
	if($typeof(condition) == $tfunction) {
		first = condition();
	}
	else {
		first = condition
	}

	if($not(istrue(first))) {
		if($typeof(false_branch) == $tfunction) {
			false_branch();
		}
		else {
			false_branch;
		}
	}
	else {
		if($typeof(true_branch) == $tfunction) {
			true_branch();
		}
		else {
			true_branch;
		}

	}
}

base_object.@0_@null@question = function() {
	if(this == base_object.@null())
		base_object.@true();
	else
		base_object.@false();
}

base_object.@1_@null@question = function(condition) {
	var first;
	if($typeof(condition) == $tfunction) {
		first = condition();
	}
	else {
		first = condition
	}
	
	if(first == null || first == base_object.@null())
		base_object.@true();
	else 
		base_object.@false();
}

base_object.@2_@null@question = function(condition, null_branch) {
	var first;
	if($typeof(condition) == $tfunction) {
		first = condition();
	}
	else {
		first = condition
	}

	if(first == null || first == base_object.@null()) {
		if($typeof(null_branch) == $tfunction) {
			null_branch();
		}
		else {
			null_branch;
		}
	}
	else {
		base_object.@false();
	}
}

base_object.@3_@null@question = function(condition, null_branch, else_branch) {
	var first;
	if($typeof(condition) == $tfunction) {
		first = condition();
	}
	else {
		first = condition
	}

	if(first == null || first == base_object.@null()) {
		if($typeof(null_branch) == $tfunction) {
			null_branch();
		}
		else {
			null_branch;
		}
	}
	else {
		if($typeof(else_branch) == $tfunction) 
			else_branch();
		else
			else_branch;
	}
}

base_object.not = function(arg) {
	if(istrue(arg)) {
		base_object.@false();
	}
	else
	{
		base_object.@true();
	}
}


has_field = function(object, field_name) {
	if(object == null || $typeof(object) != $tobject) {
		return false;
	}
        if($objfield(object, $hash(field_name))) {
                return true;
        }
        else {
                var proto = $objgetproto(object);
                if(proto == null) {
                        return false;
                }
                else {
                        return has_field(proto, field_name);
                }
        }
}

num_args = function(object, method) {
	if(object == null || $typeof(object) != $tobject) {
		$throw("Not an object:" + $string(object));
	}
        if($objfield(object, $hash(method))) {
		var meth = $objget(object, $hash(method));
		if($typeof(meth) != $tfunction)
			$throw("Tried to get argument length for non-method: " + method);

                $nargs(meth);
        }
        else {
                var proto = $objgetproto(object);
                if(proto == null) {
			$throw("No method:" + method + " for " + $string(object));
                }
                else {
                        return num_args(proto, method);
                }
        }
}


base_array = new_brat(null, null);
base_array.@internal_array = $amake(0);

base_array.new = $varargs(function(args) {
	var ary = new_brat(this, null);
	ary.@internal_array = $acopy(args);
	ary;
});

base_array.clone = $varargs(function(args) {
	if($asize(args) > 1)
		$throw("Too many arguments to array.clone(). Only takes 0 or 1.");

	var new_array = $new(this);
	$objsetproto(new_array, $objgetproto(this));

	if($asize(args) == 1) {
		if($typeof(args[0]) == $tobject)
			new_array.@value = $string(args[0].@internal_array);
		else if($typeof(args[0]) == $tarray)
			new_array.@internal_array = args[0];
		else
			$throw("Need an array argument for array.clone()");
	}

	new_array;
})


base_array.length = function() {
	base_number.new($asize(this.@internal_array));
}

base_array.__get = $varargs(function(args) {
	var len = $asize(this.@internal_array);
	if($asize(args) == 0 || $asize(args) > 2)
		$throw("Invalid number of arguments to array.get(), should be 1 or 2.");
	else if($asize(args) == 1) {
		var index = args[0].@value;
		if(index > len || index < -len) {
			return base_object.@null();
		}
		else if(index >= 0) {
			return this.@internal_array[index];
		}
		else { //index  < 0
			index = len + index;
			if(index < 0 || index >= len) {
				return base_object.@null();
			}
			else {
				return this.@internal_array[index];
			}
		}
	}
	else {
		if(len == 0) {
			this.clone($amake(0));
		}
		else {
			var start = args[0].@value;
			var stop = args[1].@value;
	
			if(start < 0)
				start = len + start;
			if(stop < 0)
				stop = len + stop;

			if(start < 0)
				start = 0;
			if(stop < 0)
				stop = 0;

			if(start > stop) {
				var temp = stop;
				stop = start;
				start = temp;
			}

			if(start >= len)
				return this.clone($amake(0));

			if(stop >= len)
				stop = len - 1;

			var new_array = $asub(this.@internal_array, start, stop - start + 1);
			this.clone(new_array);
		}		
	}

});

base_array.__set = function(index, value) {
	if($typeof(index) == $tobject && has_field(index, "@value"))
		index = index.@value;
	if($typeof(index) != $tint)
		$throw("Cannot use non-integer index for array.");

	var len = this.length().@value;
	if(index < 0)
		index = len + index;

	if(index < 0)
		$throw("Invalid array index: " + $string(index));

	if(index >= len) {
		var new_array = $amake(index - len + 1);
		var i = 0;
		var n = base_object.@null();
		while( i < (index - len + 1)) {
			new_array[i] = n;
			i += 1;
		}	
		this.@internal_array = $aconcat($array(this.@internal_array, new_array));
	}

	this.@internal_array[index] = value;
	this;
}

base_array.@less@less = function(value) {
	var old_len = $asize(this.@internal_array);
	var new_array = $amake(old_len + 1);
	$ablit(new_array, 0, this.@internal_array, 0, old_len);
	new_array[old_len] = value;
	this.@internal_array = new_array;
	this;
}

base_array.@plus = function(ary) {
	this.@internal_array = $aconcat($array(this.@internal_array, ary.@internal_array));
	this;
}

base_array.@equal@equal = function(rhs) {
	if(lhs == rhs)
		return base_object.@true();
	else if($typeof(rhs) == $tobject || has_field(rhs, "@internal_array"))
		rhs = rhs.@internal_array;
	else
		$throw("Cannot compare array to " + $string(rhs));

	var lhs = this.@internal_array;
	if($asize(lhs) != $asize(rhs))
		return base_object.@false();

	var index = 0;
	var length = $asize(lhs);
	while(index < length) {
		if($not(istrue(lhs[index].@equal@equal(rhs[index]))))
			return base_object.@false()
		else
			index = index + 1;
	}
	base_object.@true();
}

base_array.@to_s = function() {
	var i = 0;
	var len = $asize(this.@internal_array);
	var temp = $amake(len);
	while i < len {
		if(has_field(this.@internal_array[i], "@to_s"))
			temp[i] = this.@internal_array[i].@to_s();
		else if(has_field(this.@internal_array[i], "@value"))
			temp[i] = this.@internal_array[i].@value;
		else
			temp[i] = this.@internal_array[i];

		i += 1;
	}
	temp;
}


base_array.reverse = function() {
	var index = 0;
	var length = $asize(this.@internal_array);
	var new_array = $amake(length);

	while index < length + 1 {
		new_array[index] = this.@internal_array[length - index - 1];
		index = index + 1;
	}
	make_array(new_array);
}

base_array.reverse@bang = function() {
	var index = 0;
	var length = $asize(this.@internal_array);
	var new_array = $amake(length);

	while index < length + 1 {
		new_array[index] = this.@internal_array[length - index - 1];
		index = index + 1;
	}

	this.@internal_array = new_array;
	this;
}


base_array.set = base_array.__set;
base_array.get = base_array.__get;

base_hash = new_brat(null, null);
base_hash.@internal_hash = $hnew(0);

base_hash.new = $varargs(function(args) {
	var hsh = new_brat(this, null);
	if($asize(args) == 0) {
		hsh.@internal_hash = $hnew(1);
	}
	else if($typeof(args[0]) == $tabstract) {
		hsh.@internal_hash = args[0];
	}
	else {
		throw("Invalid hash initialization:" + $string(args));
	}
	hsh.length = function() { $hcount(this.@internal_hash); };
	hsh;
});

base_hash.get = function(index) {
	if(has_field(index, "@value"))
		index = index.@value;
	if($hmem(this.@internal_hash, index, null))
		$hget(this.@internal_hash, index, null);
	else
		base_object.@null();
}

base_hash.set = function(index, value) {
	if(has_field(index, "@value"))
		index = index.@value;
	$hset(this.@internal_hash, index, value, null);
	this;
}

base_hash.__set = base_hash.set;
base_hash.__get = base_hash.get;

make_hash = function(neko_hash) {
	var hsh = base_hash.new();
	hsh.@internal_hash = neko_hash;
	hsh;
}

base_hash.key@question = function(index) {
	if(has_field(index, "@value"))
		index = index.@value;
	if($hmem(this.@internal_hash, index, null))
		base_object.@true();
	else
		base_object.@false();
}

base_hash.@to_s = function() {
	output = "";
	var st = function(k,v) {
		output = $string(output + $string(k) + " : " + $string(v) + ", ");
	}

	$hiter(this.@internal_hash, st);
	
	var out = output;
	output = null;
	out;
}

hset = function(hashtable, index, value) {
	if(has_field(index, "@value"))
		index = index.@value;
	$hset(hashtable, index, value, null)
}

make_array = function(neko_array) {
	var ary = base_array.new();
	ary.@internal_array = neko_array;
	ary;
}

base_number = new_brat(null, null);
base_number.@value = 0;
base_number.@to_s = function() {
	$string(this.@value);
}

base_number.to@unders = function() {
	base_string.new($string(this.@value));
}

base_number.new = function(num) {
	var n =  new_brat(this, null);
	if($typeof(num) == $tobject)
		n.@value = num.@value;
	else
		n.@value = num;
	n;
}

base_number.@plus = function(num) {
	var lhs = this.@value;
	var rhs = num.@value;

	if($typeof(lhs) == $tint && $typeof(rhs) == $tint)
		base_number.new($iadd(lhs, rhs));
	else
		base_number.new(lhs + rhs);
}

base_number.@minus = $varargs(function(args) {
	if($asize(args) == 0)
		return base_number.new(-this.@value);
	else if($asize(args) > 1)
		$throw("Too many arguments for number.- Should be 0 or 1, given " + $string(args));
		
	var lhs = this.@value;
	var rhs = args[0].@value;

	if($typeof(lhs) == $tint && $typeof(rhs) == $tint)
		base_number.new($isub(lhs, rhs));
	else
		base_number.new(lhs - rhs);
})

base_number.@forward = function(num) {
	var lhs = this.@value;
	var rhs = num.@value;

	base_number.new(lhs / rhs);
}

base_number.@star = function(num) {
	if($typeof(num) == $tobject && has_field(num, "@value"))
		num = num.@value;

	var lhs = this.@value;
	var rhs = num;

	if($typeof(lhs) == $tint && $typeof(rhs) == $tint)
		base_number.new($imult(lhs, rhs));
	else if($typeof(lhs) == $tfloat || $typeof(rhs) == $tfloat) //could be a better check here
		base_number.new(lhs * rhs);
	else $throw("Cannot multiply " + $string(lhs) + " with " + $string(rhs));
}

base_number.@percent = function(num) {
	if($typeof(num) == $tobject && has_field(num, "@value"))
		num = num.@value;

	var lhs = this.@value;
	var rhs = num;


	if($typeof(rhs) == $tint || $typeof(rhs) == $tfloat)
		base_number.new(lhs % rhs);
	else $throw("Expected numbers for modulo, not " + $string(lhs) + " and " + $string(rhs));
}

base_number.@greater = function(num) {
	var lhs = this.@value;
	var rhs = num.@value;
	if(lhs > rhs)
		base_object.@true();
	else
		base_object.@false();
}

base_number.@less = function(num) {
	var lhs = this.@value;
	var rhs = num.@value;
	if(lhs < rhs)
		base_object.@true();
	else
		base_object.@false();
}

base_number.@less@equal = function(num) {
	var lhs = this.@value;
	var rhs = num.@value;
	if(lhs <= rhs)
		base_object.@true();
	else
		base_object.@false();
}

base_number.@greater@equal = function(num) {
	var lhs = this.@value;
	var rhs = num.@value;
	if(lhs >= rhs)
		base_object.@true();
	else
		base_object.@false();
}

base_number.@equal@equal = function(rhs) {
	var lhs = this;
	if(has_field(rhs, "@value") && has_field(lhs, "@value")) {
		rhs = rhs.@value;
		lhs = lhs.@value;
	}
	else
		return this.@false();

	if($pcompare(lhs,rhs) == 0)
		this.@true();
	else
		this.@false();
}

base_string = new_brat(null, null);
base_string.@value = "";
base_string.@to_s = function() {
	this.@value;
}

base_string.length = function() {
	base_number.new($ssize(this.@value));
}

base_string.new = $varargs(function(args) {
	var s = new_brat(this, null);
	if($asize(args) == 0) {
		s.@value = "";
	}
	else if($asize(args) == 1) {
		if($typeof(args[0]) == $tstring) {
			s.@value = args[0];
		}
		else if($typeof(args[0]) == $tobject && has_field(args[0], "@value") && $typeof(args[0].@value) == $tstring) {
			s.@value = $scopy(args[0].@value);
		}
		else if($typeof(args[0]) != $tobject) 
			s.@value = $string(args[0]);
		else
			$throw("Invalid argument to string.new(): " + $string(args[0]));
	}
	else {
		$throw("Too many arguments to string.new(). Only takes 0 or 1.");
	}
	s;
})

base_string.clone = $varargs(function(args) {
	if($asize(args) > 1)
		$throw("Too many arguments to string.clone(). Only takes 0 or 1.");

	var new_string = $new(this);
	$objsetproto(new_string, $objgetproto(this));

	if($asize(args) == 1) {
		if($typeof(args[0]) == $tobject)
			new_string.@value = $string(args[0].@value);
		else if($typeof(args[0]) == $tstring)
			new_string.@value = args[0];
		else
			$throw("Need a string argument for string.clone()");
	}

	new_string;
})

base_string.__get = $varargs(function(args) {
	var len = $ssize(this.@value);
	if($asize(args) == 0 || $asize(args) > 2)
		$throw("Invalid number of arguments to string.get(), should be 1 or 2.");
	else if($asize(args) == 1) {
		var index = args[0].@value;
		if(index > len || index < -len) {
			this.clone("");
		}
		else if(index >= 0) {
			var new_string = $ssub(this.@value, index, 1);
			return this.clone(new_string);
		}
		else { //index  < 0
			index = len + index;
			if(index < 0 || index >= len) {
				this.clone("");
			}
			else {
				var new_string = $ssub(this.@value, index, 1);
				this.clone(new_string);
			}
		}
	}
	else {
		if(len == 0) {
			this.clone("");
		}
		else {
			var start = args[0].@value;
			var stop = args[1].@value;
	
			if(start < 0)
				start = len + start;
			if(stop < 0)
				stop = len + stop;

			if(start < 0)
				start = 0;
			if(stop < 0)
				stop = 0;

			if(start > stop) {
				var temp = stop;
				stop = start;
				start = temp;
			}

			if(start >= len)
				return this.clone("");

			if(stop >= len)
				stop = len - 1;

			var new_string = $ssub(this.@value, start, stop - start + 1);
			this.clone(new_string);
		}		
	}
})

base_string.__set = function(index, value) {
	if($typeof(value) == $tobject && has_field(value, "@value"))
		value = $string(value.@value);
	if($typeof(value) != $tstring)
		$throw("Cannot set string to non-string value.");

	if($typeof(index) == $tobject && has_field(index, "@value"))
		index = index.@value;
	if($typeof(index) != $tint)
		$throw("Cannot use non-integer index for string.");


	if(index < 0)
		index = $ssize(this.@value) + index;

	if(index < 0 || index >= $ssize(this.@value))
		$throw("Invalid string index: " + $string(index) + " when string is " + $string($ssize(this.@value)) + " long.")

	$sblit(this.@value, index, value, 0, $ssize(value));
	this;
}

base_string.@plus = function(value) {
	if($typeof(value) == $tobject && has_field(value, "@value"))
		value = $string(value.@value);
	if($typeof(value) != $tstring)
		$throw("Cannot add string to non-string value.");

	var new_string = $smake($ssize(this.@value) + $ssize(value));
	$sblit(new_string, 0, this.@value, 0, $ssize(this.@value));
	$sblit(new_string, $ssize(this.@value), value, 0, $ssize(value));
	new_string;
	this.clone(new_string);
}

var reg_rep_first = $loader.loadprim("regexp@regexp_replace", 3);
var reg_rep = $loader.loadprim("regexp@regexp_replace_all", 3);
var reg_rep_fun = $loader.loadprim("regexp@regexp_replace_fun", 3);
var reg_match = $loader.loadprim("regexp@regexp_matched", 2);
var reg_matched = function(regex) { reg_match(regex, 0) }
base_string.sub = function(regexp, replacement) {
	if($typeof(regexp) == $tobject && has_field(regexp, "@internal_regex"))
		regexp = regexp.@internal_regex;
	if($typeof(replacement) == $tobject && has_field(replacement, "@value"))
		replacement = replacement.@value;
	if($typeof(regexp) != $tabstract)
		$throw("Need to provide a regular expression for string.sub()");
	var new_string;
	if($typeof(replacement) == $tstring) {
		new_string = reg_rep(regexp, this.@value, replacement);
	}
	else if($typeof(replacement) == $tfunction) {
		var f = function(m) { replacement(base_string.new(reg_matched(m))) };
		new_string = reg_rep_fun(regexp, this.@value, f);
	}
	else $throw("Need to provide a string or function for string.sub()");

	base_string.new(new_string);
}

base_string.sub@bang = function(regexp, replacement) {
	if($typeof(regexp) == $tobject && has_field(regexp, "@internal_regex"))
		regexp = regexp.@internal_regex;
	if($typeof(replacement) == $tobject && has_field(replacement, "@value"))
		replacement = replacement.@value;
	if($typeof(regexp) != $tabstract)
		$throw("Need to provide a regular expression for string.sub()");
	if($typeof(replacement) == $tstring) {
		this.@value = reg_rep(regexp, this.@value, replacement);
	}
	else if($typeof(replacement) == $tfunction) {
		var f = function(m) { replacement(base_string.new(reg_matched(m))) };
		this.@value = reg_rep_fun(regexp, this.@value, f);
	}
	else $throw("Need to provide a string or function for string.sub()");

	this;
}

base_string.sub@underfirst@bang = function(regexp, replacement) {
	if($typeof(regexp) == $tobject && has_field(regexp, "@internal_regex"))
		regexp = regexp.@internal_regex;
	if($typeof(replacement) == $tobject && has_field(replacement, "@value"))
		replacement = replacement.@value;
	if($typeof(regexp) != $tabstract)
		$throw("Need to provide a regular expression for string.sub()");
	if($typeof(replacement) == $tstring)
		this.@value = reg_rep_first(regexp, this.@value, replacement);
	else $throw("Need to provide a string for string.sub_first()");

	this;
}

base_string.sub@underfirst = function(regexp, replacement) {
	if($typeof(regexp) == $tobject && has_field(regexp, "@internal_regex"))
		regexp = regexp.@internal_regex;
	if($typeof(replacement) == $tobject && has_field(replacement, "@value"))
		replacement = replacement.@value;
	if($typeof(regexp) != $tabstract)
		$throw("Need to provide a regular expression for string.sub()");
	if($typeof(replacement) == $tstring) {
		base_string.new(reg_rep_first(regexp, this.@value, replacement));
	}
	else $throw("Need to provide a string for string.sub_first()");
}


var regexp_new = $loader.loadprim("regexp@regexp_new", 1);
base_regex = new_brat(null, null);
base_regex.@internal_regex = base_object.@null();
base_regex.new = function(regx_string) {
	if($typeof(regx_string) == $tobject && has_field(regx_string, "@value"))
		regx_string = regx_string.@value;
	if($typeof(regx_string) != $tstring)
		$throw("Must create new regex with a string, not " + $string(regx_string));

	var reg = new_brat(this, null);
	reg.@internal_regex = regexp_new(regx_string);
	reg; 
}

var regexp_match = $loader.loadprim("regexp@regexp_match", 4);
base_regex.match = function(val) {
	if($typeof(val) == $tobject && has_field(val, "@value"))
		val = val.@value;
	else
		$throw("Wrong, wrong, wrong!");

	if(regexp_match(this.@internal_regex, val, 0, $ssize(val)))
		base_object.@true();
	else
		base_object.@false();
}
base_regex.@tilde = base_regex.match;

base_symbol = new_brat(null, null);
base_symbol.new = function(sym_string) {
	if($typeof(sym_string) == $tobject && has_field(sym_string, "@value"))
		sym_string = sym_string.@value;
	if($typeof(sym_string) == $tstring)
		sym_string = $hash(sym_string);
	else
		$throw("Must create new symbol with using a string or a symbol, not " + $string(sym_string));

	var sym = new_brat(this, null);
	sym.@value = sym_string;
	sym; 
}

base_symbol.@equal@equal = function(rhs) {
	if($typeof(rhs) == $tobject && has_field(rhs, "@value"))
		rhs = rhs.@value;
	if($typeof(rhs) != $tint)
		$throw("Cannot compare symbol to " + $string(rhs));

	this.@value == rhs;
}

base_symbol.@to_s = function() {
	$field(this.@value);	
}

var run_gc = $loader.loadprim("std@run_gc", 1);
var gc_stats = $loader.loadprim("std@gc_stats", 0);

base_object.memstats = function() {
	$print("Before running gc:", gc_stats(), "\n");
	run_gc(true);
	$print("After running gc:", gc_stats(), "\n");
}

$exports.hset = hset;
$exports.make_array = make_array;
$exports.make_hash = make_hash;
$exports.has_field = has_field;
$exports.base_array = base_array;
$exports.base_hash = base_hash;
$exports.base_number = base_number;
$exports.base_string = base_string;
$exports.base_object = base_object;
$exports.base_regex = base_regex;
$exports.base_symbol = base_symbol;
$exports.num_args = num_args;
$exports.memstats = memstats;
