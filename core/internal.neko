//base_object is _the_ base object for all objects
base_object = $new(null);

base_object.new = $varargs(function(args) {
	var nb = new_brat(this);
	if(has_field(this, "init")) {
		var init = $objget(this, $hash("init"))
		if($nargs(init) == -2)
			nb.init(args);
		else
			$objcall(nb, $hash("init"), args);
	}
	else if($asize(args) > 0)
		$throw("Did not expect arguments for new().");
	
	nb;
})

//Create a new object with either parent_brat or base_object
//as the parent class.
new_brat = function(parent_brat) {
	var brat = $new(null);

	if(parent_brat == null)
		$objsetproto(brat, base_object);
	else 
		$objsetproto(brat, parent_brat);

	brat;
}

base_object.clone = function() {
	var brat = $new(this);
	$objsetproto(brat, $objgetproto(this));
	brat;
}

base_object.my = function() {
	return this;
}

base_object.parent = function() {
	var parent = $objgetproto(this);
	if(parent == null)
		base_object;
	else
		parent;
}

base_object.to@unders = function() {
	var fields = $objfields(this);
	var index = 0;
	var length = $asize(fields);
	var vals = $hnew(length);
	var cur_field;
	var name;
	var first;
	var output = "#object {"
	while index < length {
		cur_field = fields[index];
		name = $field(cur_field);
		if(name == null)
			name = "null"; //I don't know why this would happen, but it did
		name = from_identifier(name);
		first = $ssub(name, 0, 1);
		if(first != "@" && first != "_")
			output = output + " " + name;
		index = index + 1;
	} 
	base_string.new(output + " }");
}

base_object.@to_s = function() {
	this.to@unders().@value;
}

base_object.__string = function() {
	this.@to_s();
};

base_object.print = $varargs(function(args) {
	var i = 0;
	var len = $asize(args);
	while i < len {
		if(has_field(args[i], "@to_s")) {
			args[i] = args[i].@to_s();
		};
		i += 1;
	};
	$call($print, null, args);
	base_object.@@null;
})

base_object.p = $varargs(function(args) {
	var pargs = $aconcat($array(args, $array("\n")));
	$call(this.print, null, pargs);
})

base_object.squish = function(object) {
	if($typeof(object) != $tobject)
		$throw("Can only squish in objects.");

	var fields = $objfields(object);
	var num_fields = $asize(fields);
	var i = 0;
	while( i < num_fields) {
		var fval = $objget(object, fields[i]);
		if($typeof(fval) == $tfunction) {
			$objset(this, fields[i], fval);
		}
		i = i + 1;
	}
	this;
}

base_object.@function@question = function(object) {
	if($typeof(object) == $tfunction)
		base_object.@@true;
	else
		base_object.@@false;
}

base_object.object@question = function(object) {
	if($typeof(object) == $tobject)
		base_object.@@true;
	else
		base_object.@@false;
}

var random = $loader.loadprim("std@random_new", 0);
var random_int = $loader.loadprim("std@random_int", 2);
base_object.random = function(x) {
	var max ;
	if($typeof(x) == $tobject && has_field(x, "@value")) {
		max = x.@nvalue();
		if($typeof(max) == $tint)
			base_number.new(random_int(random(), max));
		else
			$throw("Expected integer, got " + $string(max));
	}
	else
		$throw("Expected number, got " + $string(x));
}

var stdin = $loader.loadprim("std@file_stdin", 0);
var read_line = $loader.loadprim("std@file_gets", 1);
var buffer_new = $loader.loadprim("std@buffer_new", 0);
var buffer_add_char = $loader.loadprim("std@buffer_add_char", 2);
var buffer_string = $loader.loadprim("std@buffer_string", 1);
base_object.g = $varargs(function(args) {
	var break_char = 10;
	if($asize(args) == 1) {
		if($typeof(args[0]) == $tobject && has_field(args[0], "@value") && $ssize(args[0].@value) == 1)
			break_char = $sget(args[0].@nvalue(), 0)
		else
			$throw("g expects to get a single character. Not " + $string(args[0]));
	}
	else if($asize(args) > 1) {
		$throw("Wrong number of arguments: g expects 0 or 1 but you gave it " + $string($asize(args)));
	}

	try {
		line = read_line(stdin());
        }
	catch e {
		return base_object.@@null;
	}
        base_string.new(line);
})

//True, false, and null values
base_object.@@false = new_brat(null);
base_object.@false = function() { base_object.@@false }
base_object.@@false.to@unders = function() { base_string.new("false") };
base_object.@@true = new_brat(null);
base_object.@true = function() { base_object.@@true }
base_object.@@true.to@unders = function() { base_string.new("true") };
base_object.@@null = new_brat(null);
base_object.@null = function() { base_object.@@null }
base_object.@@null.to@unders = function() { base_string.new("null") };

base_object.@equal@equal = function(rhs) {
	if($pcompare(this, rhs) == 0) {
		base_object.@@true;
	}
	else
		base_object.@@false;
}

base_object.@notequal = function(rhs) {
	base_object.not(this.@equal@equal(rhs));
}

var istrue = function(arg) {
	if(arg == base_object.@@null || arg == base_object.@@false) {
		false;
	}
	else {
		true;
	}
}

base_object.@true@question = $varargs(function(args) {
	switch $asize(args) {
		0 => this.@0_@true@question()
		1 => this.@1_@true@question(args[0])
		2 => this.@2_@true@question(args[0], args[1])
		3 => this.@3_@true@question(args[0], args[1], args[2])
		default => $throw("Wrong number of arguments for true? Expected 0 - 3.")
	}
})

base_object.@0_@true@question = function() {
	if(istrue(this))
		base_object.@@true;
	else
		base_object.@@false;
	
}

base_object.@1_@true@question = function(condition) {
	var first;
	if($typeof(condition) == $tfunction) {
		first = condition();
	}
	else {
		first = condition
	}

	if(istrue(first))
		base_object.@@true;
	else
		base_object.@@false;
}


base_object.@2_@true@question = function(condition, true_branch) {
	var first;
	if($typeof(condition) == $tfunction) {
		first = condition();
	}
	else {
		first = condition
	}

	if(istrue(first)) {
		if($typeof(true_branch) == $tfunction) {
			true_branch();
		}
		else {
			true_branch;
		}
	}
	else {
		first;
	}
}

base_object.@3_@true@question = function(condition, true_branch, false_branch) {
	var first;
	if($typeof(condition) == $tfunction) {
		first = condition();
	}
	else {
		first = condition
	}

	if(istrue(first)) {
		if($typeof(true_branch) == $tfunction) {
			true_branch();
		}
		else {
			true_branch;
		}
	}
	else {
		if($typeof(false_branch) == $tfunction) {
			false_branch();
		}
		else {
			false_branch;
		}
	}
}

base_object.@false@question = $varargs(function(args) {
	switch $asize(args) {
		0 => this.@0_@false@question()
		1 => this.@1_@false@question(args[0])
		2 => this.@2_@false@question(args[0], args[1])
		3 => this.@3_@false@question(args[0], args[1], args[2])
		default => $throw("Wrong number of arguments for false? Expected 0 - 3.")
	}
})


base_object.@0_@false@question = function() {
	if($not(istrue(this)))
		base_object.@@true;
	else
		base_object.@@false;
}

base_object.@1_@false@question = function(condition) {
	var first;
	if($typeof(condition) == $tfunction) {
		first = condition();
	}
	else {
		first = condition
	}

	if($not(istrue(first)))
		base_object.@@true;
	else
		base_object.@@false;
}


base_object.@2_@false@question = function(condition, false_branch) {
	var first;
	if($typeof(condition) == $tfunction) {
		first = condition();
	}
	else {
		first = condition
	}

	if($not(istrue(first))) {
		if($typeof(false_branch) == $tfunction) {
			false_branch();
		}
		else {
			false_branch;
		}
	}
	else {
		first;
	}
}

base_object.@3_@false@question = function(condition, false_branch, true_branch) {
	var first;
	if($typeof(condition) == $tfunction) {
		first = condition();
	}
	else {
		first = condition
	}

	if($not(istrue(first))) {
		if($typeof(false_branch) == $tfunction) {
			false_branch();
		}
		else {
			false_branch;
		}
	}
	else {
		if($typeof(true_branch) == $tfunction) {
			true_branch();
		}
		else {
			true_branch;
		}

	}
}

base_object.@null@question = $varargs(function(args) {
	switch $asize(args) {
		0 => this.@0_@null@question()
		1 => this.@1_@null@question(args[0])
		2 => this.@2_@null@question(args[0], args[1])
		3 => this.@3_@null@question(args[0], args[1], args[2])
		default => $throw("Wrong number of arguments for null? Expected 0 - 3.")
	}
})

base_object.@0_@null@question = function() {
	if(this == base_object.@@null)
		base_object.@@true;
	else
		base_object.@@false;
}

base_object.@1_@null@question = function(condition) {
	var first;
	if($typeof(condition) == $tfunction) {
		first = condition();
	}
	else {
		first = condition
	}
	
	if(first == null || first == base_object.@@null)
		base_object.@@true;
	else 
		base_object.@@false;
}

base_object.@2_@null@question = function(condition, null_branch) {
	var first;
	if($typeof(condition) == $tfunction) {
		first = condition();
	}
	else {
		first = condition
	}

	if(first == null || first == base_object.@@null) {
		if($typeof(null_branch) == $tfunction) {
			null_branch();
		}
		else {
			null_branch;
		}
	}
	else {
		base_object.@@false;
	}
}

base_object.@3_@null@question = function(condition, null_branch, else_branch) {
	var first;
	if($typeof(condition) == $tfunction) {
		first = condition();
	}
	else {
		first = condition
	}

	if(first == null || first == base_object.@@null) {
		if($typeof(null_branch) == $tfunction) {
			null_branch();
		}
		else {
			null_branch;
		}
	}
	else {
		if($typeof(else_branch) == $tfunction) 
			else_branch();
		else
			else_branch;
	}
}

base_object.not = function(arg) {
	if(istrue(arg)) {
		base_object.@@false;
	}
	else
	{
		base_object.@@true;
	}
}

base_object.@while = $varargs(function(args) {
	switch $asize(args) {
		1 => this.@1_@while(args[0])
		2 => this.@2_@while(args[0], args[1])
		default => $throw("While expects 1 or 2 arguments.")
	}
})

base_object.@1_@while = function(block) {
	while(istrue(block())) {}
}

base_object.@2_@while = function(condition, block) {
	while(($typeof(condition) == $tfunction && istrue(condition())) || ($typeof(condition) != $tfunction && istrue(condition))) { block() }
}

base_object.when = $varargs(function(args) {
	var arglen = $asize(args);
	if(arglen < 2) {
		$throw("When requires at least 2 arguments.");
	} 
	else if(arglen % 2 == 0) {
		
	}
	else {

	}	
})

base_object.import = $varargs(function(args) {
	if($asize(args) == 1) {
		if(has_field(args[0], "@value")) {
			var m = $loader.loadmodule(to_identifier(args[0].@value), $loader);
			var imp = base_object.new();
			var f = $objfields(m);
			var fs = $asize(f);
			var index = 0;
			var field;
			while(index < fs) {
				field = $objget(m, f[index]);
				if($typeof(field) == $tobject)
					$objset(imp, f[index], function() { field });
				else if($typeof(field) == $tfunction)
					$objset(imp, f[index], field);
				else if($field(f[index]) == "__module") {}
				else
					$throw("Cannot import: " + $string($field(f[index])));

				index = index + 1;
			}
			imp;
		}
		else
			$throw("Import expects a string, not " + $string(args[0]));
	}
	else if($asize(args) == 2) {
		if(has_field(args[0], "@value") && has_field(args[1], "@value")) {
			var m = $loader.loadmodule(args[0].@value, $loader);
			var name = $hash(to_identifier(args[1].@value));
			if($objfield(m, name)) {
				$objget(m, name);
			}
			else
				$throw("Module " + args[0].@value + " does not have an export named " + args[1].@value);
		}
		else
			$throw("Import expects two string arguments.");
	}
	else
		$throw("Import requires either 1 or 2 parameters.");
})

base_object.export = function(object, name) {
	if(has_field(name, "@value")) {
		$objset($exports, $hash(to_identifier(name.@value)), object);
	}
	else
		$throw("Import expects a string, not " + $string(name));
}

base_object.add@undermethod = function(name, block) {
	name = to_identifier(name);

	$objset(this, $hash(name), block);
	this;
}

base_object.del@undermethod = function(name) {
	name = to_identifier(name);
	$objremove(this, $hash(name));
	this;
}

base_object.get@undermethod = function(name) {
	var m = $objget(this, $hash(to_identifier(name)));

	if(m == null) {
		var proto = $objgetproto(this);
        	if(proto == null) {
			base_object.@@null;
        	}
	        else {
			proto.get@undermethod(name);
	        }
	}		
	else
		m;
}

base_object.has@undermethod@question = function(name) {
	if(has_field(name, "@neko_string")) {
		if(has_field(this, to_identifier(name.@neko_string())))
			base_object.@@true;
		else
			base_object.@@false;
	}
	else
		$throw("has_method? expects a string.");
}

base_object.call@undermethod = $varargs(function(args) {
	var arglen = $asize(args);
	if(arglen < 1)
		$throw("Call_method requires at least one argument.")

	var m = this.get@undermethod(args[0]);

	if(m == base_object.@@null)
		$throw("No such method " + $string(args[0]) + " for " + $string(this) + "."); 

	var nargs = $nargs(m);
	if(nargs != -1 && nargs != arglen - 1)
		$throw($string(args[0]) + " requires " + $string(nargs) + " argument(s).");

	if(arglen > 1)
		$call(m, this, $asub(args, 1, arglen - 1));
	else
		$call(m, this, $amake(0));
});

base_object.methods = function() {
	var meths = $objfields(this);
	var i = 0; 
	var field;
	var name;
	while(i < $asize(meths)) {
		field = $field(meths[i]);
		if(field == null)
			$throw("Unable to retrieve string for field, for some weird reason.");
		name = from_identifier(field);
		meths[i] = base_string.new(name);
		i = i + 1;
	}

	var proto = $objgetproto(this);
	meths = base_array.new(meths).select(function(i) { base_object.not(i[base_number.new(0)].@equal@equal(base_string.new("@")))});
	if(proto == null)
		meths;
	else {
		meths.@plus(proto.methods());
	}
}

base_object.local@undermethods = function() {
	var meths = $objfields(this);
	var i = 0; 
	var field;
	var name;
	while(i < $asize(meths)) {
		field = $field(meths[i]);
		if(field == null)
			$throw("Unable to retrieve string for field, for some weird reason.");
		name = from_identifier(field);
		meths[i] = base_string.new(name);
		i = i + 1;
	}

	meths = base_array.new(meths).select(function(i) { base_object.not(i[base_number.new(0)].@equal@equal(base_string.new("@")))});
}

base_object.with@underthis = function(block) {
	block();
}

base_object.method@underarity = function(func) {
	if($typeof(func) == $tfunction) {
		var args = $nargs(func);
		if(args < 0)
			base_number.new(-1);
		else
			base_number.new(args);
	}
	else
		$throw($string(func) + " is not a function, cannot report its arity.");
}

var sys_exit = $loader.loadprim("std@sys_exit", 1);
base_object.exit = $varargs(function(exit_code) {
	if($asize(exit_code) == 0)
		sys_exit(0);
	else if($asize(exit_code) == 1) {
		exit_code = exit_code[0];
		if($typeof(exit_code) == $tobject && has_field(exit_code, "@nvalue"))
			sys_exit(exit_code.@nvalue());
		else if($typeof(exit_code) == $tint)
			sys_exit(exit_code);
		else
			$throw("Argument for exit should be an integer.");
	}
	else {
		$throw("Wrong number of arguments for exit. Expects 0 or 1.");
	}

});

var sys_sleep = $loader.loadprim("std@sys_sleep", 1);
base_object.sleep = function(seconds) {
	if($typeof(seconds) == $tobject && has_field(seconds, "@nvalue"))
		seconds = seconds.@nvalue();
	else if($typeof(seconds) != $tint && $typeof(seconds) != $tfloat)
		$throw("Expected a number for sleep(), got " + $string(seconds));

	sys_sleep(seconds);
}

has_field = function(object, field_name) {
	$typeof(object) == $tobject && $objget(object, $hash(field_name)) != null
}

num_args = function(object, method) {
	if(object == null || $typeof(object) != $tobject) {
		$throw("Not an object:" + $string(object));
	}
        if($objfield(object, $hash(method))) {
		var meth = $objget(object, $hash(method));
		if($typeof(meth) != $tfunction)
			$throw("Tried to get argument length for non-method: " + method);

                $nargs(meth);
        }
        else {
                var proto = $objgetproto(object);
                if(proto == null) {
			$throw("No method:" + method + " for " + $string(object));
                }
                else {
                        return num_args(proto, method);
                }
        }
}

//Number functions
var f_from_s = $loader.loadprim("number@float_from_string", 1);
var i_from_s = $loader.loadprim("number@integer_from_string", 1);
var num_add = $loader.loadprim("number@num_add", 2);
var num_sub = $loader.loadprim("number@num_sub", 2);
var num_mul = $loader.loadprim("number@num_mul", 2);
var num_div = $loader.loadprim("number@num_div", 2);
var num_cmp = $loader.loadprim("number@num_cmp", 2);
var is_num = $loader.loadprim("number@is_num", 1);
var is_int = $loader.loadprim("number@is_int", 1);
var is_float = $loader.loadprim("number@is_float", 1);
var num_to_string = $loader.loadprim("number@num_to_string", 1);
var num_to_float = $loader.loadprim("number@int_to_float", 1);
var num_to_int = $loader.loadprim("number@float_to_int", 1);
var integer_from_int = $loader.loadprim("number@integer_from_int", 1);
var float_from_float = $loader.loadprim("number@float_from_float", 1);
var num_neg = $loader.loadprim("number@num_neg", 1);
var to_neko_num = $loader.loadprim("number@to_neko_num", 1);
var to_bignum = $loader.loadprim("number@to_bignum", 1);
var integer_fits = $loader.loadprim("number@integer_fits_native", 1);
base_number = new_brat(null);
base_number.@value = 0;
base_number.@native = true;
base_number.@to_s = function() {
	this.to@unders().@value;
}

base_number.to@unders = function() {
	if(this.@native)
		return base_string.new($string(this.@value));
	var s = num_to_string(this.@value);
	var str = base_string.new(s);
	if($sfind(str.@value, 0, ".") != null) {
		var r = base_regex.new("\\.?0+$");
		str.sub@underfirst@bang(r, "");
	}
	str;
}

base_number.native@question = function() {
	if(this.@native)
		base_object.@@true;
	else
		base_object.@@false;
}

base_number.to@underi = function() {
	if(this.@native)
		base_number.new($int(this.@value));
	else
		base_number.new(num_to_int(this.@value));
}

base_number.to@underf = function() {
	if(this.@native)
		base_number.new($float(this.@value));
	else
		base_number.new(num_to_float(this.@value));
}

base_number.@nvalue = function() {
	if(this.@native)
		this.@value;
	else
		to_neko_num(this.@value);
}

base_number.new = function(num) {
	var n = new_brat(this);
	if($typeof(num) == $tint || $typeof(num) == $tfloat) {
		n.@value = num;
		n.@native = true
	}
	else if($typeof(num) == $tobject) {
		if($typeof(num.@value) == $tint || $typeof(num.@value) == $tfloat) {
			n.@value = num;
			n.@native = true
		}
		else if(is_num(num.@value)) {
			n.@value = num.@value;
			n.@native = false
		}
		else
			$throw("Expected number, not " + $string(num));
	}
	else if(is_num(num)) {
		if(integer_fits(num)) {
			n.@value = to_neko_num(num);
			n.@native = true; 
		}
		else {
			n.@value = num;
			n.@native = false
		}
	}
	else
		$throw("Expected number, not " + $string(num));

	n;
}

base_number.@stoi = function(str) {
	base_number.new(i_from_s(str));
}

base_number.@stof = function(str) {
	base_number.new(f_from_s(str));
}

base_number.@plus = function(num) {
	var lhs = this.@value;
	var rhs = num.@value;

	if(this.@native && num.@native) {
		var res = lhs + rhs;
		if(lhs >= 0 && rhs >= 0 && res >= lhs)
			base_number.new(res);
		else {
			lhs = to_bignum(lhs);
			rhs = to_bignum(rhs); 
			base_number.new(num_add(lhs, rhs));
		}
	}
	else if(is_num(rhs) && is_num(lhs))
		base_number.new(num_add(lhs, rhs));
	else if((is_num(rhs) && this.@native) || (is_num(lhs) && num.@native)) {
		lhs = to_bignum(lhs);
		rhs = to_bignum(rhs);
		base_number.new(num_add(lhs, rhs));
	}
	else
		$throw("Expected numbers to add, not " + $string(num) + " and " + $string(this));
}

base_number.@minus = $varargs(function(args) {
	if($asize(args) == 0) {
		if(this.@native)
			return base_number.new(-this.@value);
		else
			return base_number.new(num_neg(this.@value));
	}
	else if($asize(args) > 1)
		$throw("Too many arguments for number.- Should be 0 or 1, given " + $string(args));
		
	var lhs = this.@value;
	var rhs = args[0].@value;

	if(this.@native && args[0].@native) {
		var res = lhs - rhs;
		if(lhs >= 0 && rhs >= 0 && res <= lhs)
			base_number.new(res);
		else if(lhs < 0 && rhs < 0 && res > lhs)
			base_number.new(res);
		else {
			lhs = to_bignum(lhs);
			rhs = to_bignum(rhs); 
			base_number.new(num_sub(lhs, rhs));
		}
	}
	else if(is_num(rhs) && is_num(lhs))
		base_number.new(num_sub(lhs, rhs));
	else if((is_num(rhs) && this.@native) || (is_num(lhs) && args[0].@native)) {
		lhs = to_bignum(lhs);
		rhs = to_bignum(rhs);
		base_number.new(num_sub(lhs, rhs));
	}
	else
		$throw("Expected numbers to subtract, not " + $string(args[0]) + " and " + $string(this));
})

base_number.@forward = function(num) {
	var lhs = this.@value;
	var rhs = num.@value;

	if(this.@native && num.@native) {
		lhs = to_bignum(lhs);
		rhs = to_bignum(rhs); 
		base_number.new(num_div(lhs, rhs));
	}
	else if(is_num(rhs) && is_num(lhs))
		base_number.new(num_div(lhs, rhs));
	else if((is_num(rhs) && this.@native) || (is_num(lhs) && num.@native)) {
		lhs = to_bignum(lhs);
		rhs = to_bignum(rhs);
		base_number.new(num_div(lhs, rhs));
	}
	else
		$throw("Expected numbers to divide, not " + $string(num) + " and " + $string(this));

}

base_number.@star = function(num) {
	var lhs = this.@value;
	var rhs = num.@value;

	if(this.@native && num.@native) {
		lhs = to_bignum(lhs);
		rhs = to_bignum(rhs); 
		base_number.new(num_mul(lhs, rhs));
	}
	else if(is_num(rhs) && is_num(lhs)) {
		base_number.new(num_mul(lhs, rhs));
	}
	else if((is_num(rhs) && this.@native) || (is_num(lhs) && num.@native)) {
		lhs = to_bignum(lhs);
		rhs = to_bignum(rhs);
		base_number.new(num_mul(lhs, rhs));
	}
	else
		$throw("Expected numbers to multiply, not " + $string(num) + " and " + $string(this));
}

base_number.@percent = function(num) {
	var lhs = this.@value;
	var rhs = num.@value;

	if(this.@native && num.@native) {
		base_number.new(lhs, rhs);
	}
	else if(is_int(rhs) && is_int(lhs))
		base_number.new(int_mod(lhs, rhs));
	else
		$throw("Expected integers for modulo, not " + $string(num) + " and " + $string(this));

}

base_number.@less@equal@greater = function(num) {
	if(has_field(num, "@native")) {
		var rhs = num.@value;
		var lhs = this.@value;

		if(this.@native && num.@native)
			base_number.new($compare(lhs,rhs));
		else if(is_num(lhs) && is_num(rhs)) 
			base_number.new(num_cmp(lhs, rhs));
		else 
			base_number.new(num_cmp(to_bignum(lhs), to_bignum(rhs)));
	}
	else
		$throw("Cannot compare " + $string(this) + " and " + $string(num));
}

base_number.@equal@equal = function(num) {
	if($not(has_field(num, "@native")))
		base_object.@@false;
	else if(this.@less@equal@greater(num).@value == 0)
		base_object.@@true;
	else
		base_object.@@false;
}

//Array object
base_array = new_brat(null);
base_array.@internal_array = $amake(0);

base_array.new = $varargs(function(args) {
	var ary = new_brat(this);
	if($asize(args) > 0) {
		if($asize(args) == 1 && $typeof(args[0]) == $tarray)
			args = args[0];

		ary.@internal_array = args;
		ary.@length = $asize(args);
	}
	else {
		ary.@internal_array = $amake(16);
		ary.@length = 0;
	}
	ary;
});

base_array.@neko_array = function() { 
	if(this.@length == $asize(this.@internal_array))
		this.@internal_array
	else
		$asub(this.@internal_array, 0, this.@length);
}

base_array.length = function() {
	base_number.new(this.@length);
}

base_array.reserve = function(size) {
	if($typeof(size) != $tobject || $not(has_field(size, "@nvalue")))
		$throw("Array.reserve expects integer.");

	size = size.@nvalue();
	var empty = $asize(this.@internal_array) - this.@length;
	if(size > empty)
		this.@internal_array = $aconcat($array(this.@internal_array, $amake(size - empty)));

	this;
}

base_array.__get = $varargs(function(args) {
	var len = this.@length;
	if($asize(args) == 0 || $asize(args) > 2)
		$throw("Invalid number of arguments to array.get(), should be 1 or 2.");
	else if($asize(args) == 1) {
		if($not(has_field(args[0], "@nvalue")))
			$throw("Cannot access array with non-number value.");

		var index = args[0].@nvalue();
		if(index >= len || index < -len) {
			return base_object.@@null;
		}
		else if(index >= 0) {
			return this.@internal_array[index];
		}
		else { //index  < 0
			index = len + index;
			if(index < 0 || index >= len) {
				return base_object.@@null;
			}
			else {
				return this.@internal_array[index];
			}
		}
	}
	else {
		if($not(has_field(args[0], "@nvalue")) || $not(has_field(args[1], "@nvalue")))
			$throw("Cannot access array with non-number value.");

		if(len == 0) {
			this.new(); //return empty array
		}
		else {
			var start = args[0].@nvalue();
			var stop = args[1].@nvalue();

			if(start < 0)
				start = len + start;
			if(stop < 0)
				stop = len + stop;

			if(start < 0)
				start = 0;
			if(stop < 0)
				stop = 0;

			if(start > stop) {
				var temp = stop;
				stop = start;
				start = temp;
			}

			if(start >= len)
				return this.new();

			if(stop >= len)
				stop = len - 1;

			var new_array = $asub(this.@internal_array, start, stop - start + 1);
			base_array.new(new_array);
		}
	}
});

base_array.__set = function(index, value) {
	if($typeof(index) == $tobject && has_field(index, "@nvalue"))
		index = index.@nvalue();
	if($typeof(index) != $tint)
		$throw("Cannot use non-integer index for array.");

	var len = this.@length;
	if(index < 0)
		index = len + index;

	if(index < 0)
		$throw("Invalid array index: " + $string(index));

	if(index >= len) {

		if(index < $asize(this.@internal_array)) { //no need to resize
			var i = this.@length;
			var n = base_object.@@null;
			while(i < index) {
				this.@internal_array[i] = n;
				i = i + 1;
			}
		}
		else {
			len = $asize(this.@internal_array);
			var new_array = $amake(index - len + 1);
			var i = 0;
			var n = base_object.@@null;
			var stop = index - len + 1;
			while( i < stop) {
				new_array[i] = n;
				i += 1;
			}

			i = this.@length;
			while(i < len) {
				this.@internal_array[i] = n;
			}

			this.@internal_array = $aconcat($array(this.@internal_array, new_array));
		}
	}

	this.@length = index + 1;
	this.@internal_array[index] = value;
	this;
}

base_array.push = function(value) {
	if(this.@length == $asize(this.@internal_array)) {	//resize
		var new_array = $amake((this.@length + 1) * 2);
		//this.@internal_array = $aconcat($array(this.@internal_array, new_array));
		$ablit(new_array, 0, this.@internal_array, 0, this.@length);
		this.@internal_array = new_array;
	}

	this.@internal_array[this.@length] = value;
	this.@length = this.@length + 1;

	this;
}

base_array.@less@less = base_array.push;

base_array.@plus = function(ary) {
	this.@internal_array = $aconcat($array(this.@neko_array(), ary.@neko_array()));
	this.@length = this.@length + ary.@length;
	this;
}

base_array.@equal@equal = function(rhs) {
	if(lhs == rhs)
		return base_object.@@true;
	else if($typeof(rhs) != $tobject || $not(has_field(rhs, "@neko_array")))
		return base_object.@@false;

	var lhs = this.@internal_array;
	if(lhs == null) {
		$throw($string(this) + " has a null array");
	}
	else if(rhs.@internal_array == null) {
		$throw("rhs has a null array");
	}
	if(this.@length != rhs.@length)
		return base_object.@@false;

	rhs = rhs.@internal_array;
	var index = 0;
	var length = this.@length;
	while(index < length) {
		if($not(istrue(lhs[index].@equal@equal(rhs[index]))))
			return base_object.@@false
		else
			index = index + 1;
	}
	base_object.@@true;
}

base_array.@to_s = function() {
	var i = 0;
	var len = this.@length;
	var temp = $amake(len);
	while i < len {
		if(has_field(this.@internal_array[i], "@to_s"))
			temp[i] = this.@internal_array[i].@to_s();
		else
			temp[i] = this.@internal_array[i];

		i += 1;
	}
	$string(temp);
}

base_array.reverse = function() {
	var index = 0;
	var length = this.@length;
	var new_array = $amake(length);

	while index < length + 1 {
		new_array[index] = this.@internal_array[length - index - 1];
		index = index + 1;
	}
	base_array.new(new_array);
}

base_array.reverse@bang = function() {
	var index = 0;
	var length = this.@length;
	var new_array = $amake(length);

	while index < length + 1 {
		new_array[index] = this.@internal_array[length - index - 1];
		index = index + 1;
	}

	this.@internal_array = new_array;
	this;
}

base_array.clear = function() {
	//this.@internal_array = $amake(0);
	this.@length = 0;
	this;
}

base_array.delete@underfirst = function(item) {
	var index = 0;
	var found = null;
	var length = this.@length;

	var compare;

	if($typeof(item) == $tobject) {
		compare = function(current) {
			item.@equal@equal(current) == base_object.@@true;
		}
	}
	else {
		compare = function(current) {
			item == current;
		}
	}

	while index < length + 1 {
		if(compare(this.@internal_array[index])) {
			found = index;
			break;
		}
		index = index + 1;
	}

	if(found != null) {
		if(found == this.@length - 1) {
			this.@internal_array[found] = null;
			this.@length = this.@length - 1;
		}
		else {
			var temp = $amake(length - 1);
			if(found > 0)
				$ablit(temp, 0, this.@internal_array, 0, found);

			if(found < length)
				$ablit(temp, found, this.@internal_array, found + 1, this.@length - found - 1);
	
			this.@internal_array = temp;
			this.@length = $asize(this.@internal_array);
		}
		this;
	}
	else
		this;
	
}

partition = function(array, left, right, pivot) {
	var pivot_value = array[pivot];
	if($typeof(pivot_value) != $tobject || $not(has_field(pivot_value, "@greater@equal")))
		$throw("Cannot compare " + $string(pivot_value) + " in order to sort it.");
	var temp = array[pivot];
	array[pivot] = array[right];
	array[right] = temp;
	store_index = left;
	var i = left;
	while(i < right) {
		if(pivot_value.@greater@equal(array[i]) == base_object.@@true) {
			temp = array[store_index];
			array[store_index] = array[i];
			array[i] = temp;
			store_index = store_index + 1;
		}
		i = i + 1;
	}
	temp = array[store_index];
	array[store_index] = array[right];
	array[right] = temp;
	store_index;
}

quick_sort = function(array, left, right) {
	if(right > left) {
		var pivot = random_int(random(), right - left) + left;
		var new_pivot = partition(array, left, right, pivot);
		quick_sort(array, left, new_pivot - 1);
		quick_sort(array, new_pivot + 1, right);
	}
}

base_array.sort = function() {
	var array = $asub(this.@internal_array, 0, this.@length);
	quick_sort(array, 0, $asize(array) - 1);
	base_array.new(array);
}

base_array.sort@bang = function() {
	quick_sort(this.@internal_array, 0, this.@length - 1);
	this;
}

base_array.set = base_array.__set;
base_array.get = base_array.__get;

//Hash table object
base_hash = new_brat(null);
base_hash.@internal_hash = $hnew(10);
base_hash.@compare = function(lhs, rhs) {
	if($typeof(lhs) == $tobject && $typeof(rhs) == $tobject) {
		if(istrue(lhs.@equal@equal(rhs)))
			0;
		else
			-1;
	}
	else 
		$compare(lhs, rhs);
}

base_hash.@key_value = function(key) {
	var t = $typeof(key);
	if(t == $tobject)
		key;
	else if(t == $tint || t == $tfloat)
		base_number.new(key);
	else if(t == $tstring)
		base_string.new(key);
	else if(t == $tbool) {
		if(key)
			base_object.@@true;
		else
			base_object.@@false;
	}
	else if(t == $tnull)
		base_object.@@null;
	else if(t == $tarray)
		base_array.new(key);
	else {
		key;
	}
}

base_hash.new = $varargs(function(args) {
	var hsh = new_brat(this);
	if($asize(args) == 0) {
		hsh.@internal_hash = $hnew(1);
	}
	else if($typeof(args[0]) == $tabstract) {
		hsh.@internal_hash = args[0];
	}
	else {
		throw("Invalid hash initialization:" + $string(args));
	}
	hsh;
});

base_hash.get = function(index) {
	if($hmem(this.@internal_hash, index, base_hash.@compare) == true)
		$hget(this.@internal_hash, index, base_hash.@compare);
	else
		base_object.@@null;
}

base_hash.set = function(index, value) {
	$hset(this.@internal_hash, index, value, base_hash.@compare);
	this;
}

base_hash.__set = base_hash.set;
base_hash.__get = base_hash.get;

make_hash = function(neko_hash) {
	var hsh = base_hash.new();
	hsh.@internal_hash = neko_hash;
	hsh;
}

base_hash.key@question = function(index) {
	if($hmem(this.@internal_hash, index, base_hash.@compare))
		base_object.@@true;
	else
		base_object.@@false;
}

base_hash.each = function(block) {
	$hiter(this.@internal_hash, block);
	this;
}

base_hash.each@underkey = function(block) {
	var f = function(k,v) {
		block(k);
	}

	$hiter(this.@internal_hash, f);
	this;
}

base_hash.each@undervalue = function(block) {
	var f = function(k,v) {
		block(v);
	}

	$hiter(this.@internal_hash, f);
	this;
}

base_hash.delete = function(key) {
	$hremove(this.@internal_hash, key, base_hash.@compare);
	this;
}

base_hash.length = function() {
	base_number.new($hcount(this.@internal_hash));
}

base_hash.select = function(block) {
	var res = $hnew(5);
	var test = function(key, value) { 
		if(istrue(block(key, value)))
			$hset(res, key, value, base_hash.@compare);
	}
	$hiter(this.@internal_hash, test);
	make_hash(res);
}

base_hash.map = function(block) {
	var res = $amake($hcount(this.@internal_hash));
	var i = 0;
	var fun = function(key, value) {
		res[i] = block(key, value);
		i = i + 1;
	}

	$hiter(this.@internal_hash, fun);
	base_array.new(res);
}

base_hash.keys = function() {
	var fun = function(key, value) {
		key;
	}
	this.map(fun);
}

base_hash.empty@question = function() {
	if($hcount(this.@internal_hash) == 0)
		base_object.@@true;
	else
		base_object.@@false;
}

base_hash.@to_s = function() {
	output = "";
	var st = function(k,v) {
		output = $string(output + $string(k) + " : " + $string(v) + ", ");
	}

	$hiter(this.@internal_hash, st);

	var out = output;
	output = null;
	out;
}

hset = function(hashtable, index, value) {
	$hset(hashtable, index, value, base_hash.@compare)
}


base_string = new_brat(null);
base_string.@value = "";
base_string.@to_s = function() {
	this.@value;
}

base_string.@neko_string = function() { this.@value }

base_string.to@unders = function() { this }

base_string.@equal@equal = function(rhs) {
	if($typeof(rhs) == $tobject && has_field(rhs, "@neko_string")) {
		if($compare(this.@neko_string(), rhs.@neko_string()) == 0)
			base_object.@@true;
		else
			base_object.@@false;
	}
	else
		base_object.@@false;
}

base_string.@less@equal@greater = function(rhs) {
	if($typeof(rhs) == $tobject && has_field(rhs, "@neko_string")) {
		base_number.new($compare(this.@neko_string(), rhs.@neko_string()));
	}
	else
		$throw("Cannot compare " + $string(this) + " and " + $string(rhs));
}

base_string.to@underi = function() {
	var ts = this.sub(base_regex.new("\\.\\d*$"), "");
	base_number.new(i_from_s(ts.@value));
}

base_string.to@underf = function() {
	base_number.new(f_from_s(this.@value));
}

base_string.length = function() {
	base_number.new($ssize(this.@value));
}

base_string.new = $varargs(function(args) {
	var s = new_brat(this);
	if($asize(args) == 0) {
		s.@value = "";
	}
	else if($asize(args) == 1) {
		if($typeof(args[0]) == $tstring) {
			s.@value = args[0];
		}
		else if($typeof(args[0]) == $tobject && has_field(args[0], "@neko_string")) {
			s.@value = $scopy(args[0].@value);
		}
		else if($typeof(args[0]) != $tobject) 
			s.@value = $string(args[0]);
		else
			$throw("Invalid argument to string.new(): " + $string(args[0]));
	}
	else
		$throw("Too many arguments to string.new(). Only takes 0 or 1.");
	s;
});

base_string.clone = $varargs(function(args) {
	if($asize(args) > 1)
		$throw("Too many arguments to string.clone(). Only takes 0 or 1.");

	var new_string = $new(this);
	$objsetproto(new_string, $objgetproto(this));

	if($asize(args) == 1) {
		if($typeof(args[0]) == $tobject)
			new_string.@value = $string(args[0].@value);
		else if($typeof(args[0]) == $tstring)
			new_string.@value = args[0];
		else
			$throw("Need a string argument for string.clone()");
	}

	new_string;
})

base_string.__get = $varargs(function(args) {
	var len = $ssize(this.@value);
	if($asize(args) == 0 || $asize(args) > 2)
		$throw("Invalid number of arguments to string.get(), should be 1 or 2.");
	else if($asize(args) == 1) {
		if($not(has_field(args[0], "@nvalue")))
			$throw("Cannot index string with non-number value.");

		var index = args[0].@nvalue();
		if(index >= len || index < -len) {
			this.clone("");
		}
		else if(index >= 0) {
			var new_string = $ssub(this.@value, index, 1);
			return this.clone(new_string);
		}
		else { //index  < 0
			index = len + index;
			if(index < 0 || index >= len) {
				this.clone("");
			}
			else {
				var new_string = $ssub(this.@value, index, 1);
				this.clone(new_string);
			}
		}
	}
	else {
		if($not(has_field(args[0], "@nvalue")) || $not(has_field(args[1], "@nvalue")))
			$throw("Cannot index string with non-number value.");
		if(len == 0) {
			this.clone("");
		}
		else {
			var start = args[0].@nvalue();
			var stop = args[1].@nvalue();
			if(start < 0)
				start = len + start;
			if(stop < 0)
				stop = len + stop;

			if(start < 0)
				start = 0;
			if(stop < 0)
				stop = 0;

			if(start > stop) {
				var temp = stop;
				stop = start;
				start = temp;
			}

			if(start >= len)
				return this.clone("");

			if(stop >= len)
				stop = len - 1;

			var new_string = $ssub(this.@value, start, stop - start + 1);
			this.clone(new_string);
		}		
	}
})

base_string.__set = function(index, value) {
	if($typeof(value) == $tobject && has_field(value, "@value"))
		value = $string(value.@value);
	if($typeof(value) != $tstring)
		$throw("Cannot set string to non-string value.");


	if($typeof(index) == $tobject && has_field(index, "@nvalue"))
		index = index.@nvalue();
	else if($typeof(index) == $tobject && has_field(index, "@value"))
		index = index.@value;

	if($typeof(index) != $tint)
		$throw("Cannot use non-integer index for string.");

	if(index < 0)
		index = $ssize(this.@value) + index;

	if(index < 0 || index >= $ssize(this.@value))
		$throw("Invalid string index: " + $string(index) + " when string is " + $string($ssize(this.@value)) + " long.")

			$sblit(this.@value, index, value, 0, $ssize(value));
	this;
}

base_string.@plus = function(value) {
	if($typeof(value) == $tobject && has_field(value, "@value"))
		value = $string(value.@value);
	if($typeof(value) != $tstring)
		$throw("Cannot add string to non-string value.");

	var new_string = $smake($ssize(this.@value) + $ssize(value));
	$sblit(new_string, 0, this.@value, 0, $ssize(this.@value));
	$sblit(new_string, $ssize(this.@value), value, 0, $ssize(value));
	new_string;
	this.clone(new_string);
}

var reg_rep_first = $loader.loadprim("regexp@regexp_replace", 3);
var reg_rep = $loader.loadprim("regexp@regexp_replace_all", 3);
var reg_rep_fun = $loader.loadprim("regexp@regexp_replace_fun", 3);
var reg_match = $loader.loadprim("regexp@regexp_matched", 2);
var reg_matched = function(regex) { reg_match(regex, 0) }
base_string.sub = function(regexp, replacement) {
	if($typeof(regexp) == $tobject && has_field(regexp, "@internal_regex"))
		regexp = regexp.@internal_regex;
	if($typeof(replacement) == $tobject && has_field(replacement, "@value"))
		replacement = replacement.@value;
	if($typeof(regexp) != $tabstract)
		$throw("Need to provide a regular expression for string.sub()");
	var new_string;
	if($typeof(replacement) == $tstring) {
		new_string = reg_rep(regexp, this.@value, replacement);
	}
	else if($typeof(replacement) == $tfunction) {
		var f = function(m) { replacement(base_string.new(reg_matched(m))) };
		new_string = reg_rep_fun(regexp, this.@value, f);
	}
	else $throw("Need to provide a string or function for string.sub()");

	base_string.new(new_string);
}

base_string.sub@bang = function(regexp, replacement) {
	if($typeof(regexp) == $tobject && has_field(regexp, "@internal_regex"))
		regexp = regexp.@internal_regex;
	if($typeof(replacement) == $tobject && has_field(replacement, "@value"))
		replacement = replacement.@value;
	if($typeof(regexp) != $tabstract)
		$throw("Need to provide a regular expression for string.sub()");
	if($typeof(replacement) == $tstring) {
		this.@value = reg_rep(regexp, this.@value, replacement);
	}
	else if($typeof(replacement) == $tfunction) {
		var f = function(m) { replacement(base_string.new(reg_matched(m))) };
		this.@value = reg_rep_fun(regexp, this.@value, f);
	}
	else $throw("Need to provide a string or function for string.sub()");

	this;
}

base_string.sub@underfirst@bang = function(regexp, replacement) {
	if($typeof(regexp) == $tobject && has_field(regexp, "@internal_regex"))
		regexp = regexp.@internal_regex;
	if($typeof(replacement) == $tobject && has_field(replacement, "@value"))
		replacement = replacement.@value;
	if($typeof(regexp) != $tabstract)
		$throw("Need to provide a regular expression for string.sub_first()");
	if($typeof(replacement) == $tstring)
		this.@value = reg_rep_first(regexp, this.@value, replacement);
	else $throw("Need to provide a string for string.sub_first()");

	this;
}

base_string.sub@underfirst = function(regexp, replacement) {
	if($typeof(regexp) == $tobject && has_field(regexp, "@internal_regex"))
		regexp = regexp.@internal_regex;
	if($typeof(replacement) == $tobject && has_field(replacement, "@value"))
		replacement = replacement.@value;
	if($typeof(regexp) != $tabstract)
		$throw("Need to provide a regular expression for string.sub_first()");
	if($typeof(replacement) == $tstring) {
		base_string.new(reg_rep_first(regexp, this.@value, replacement));
	}
	else $throw("Need to provide a string for string.sub_first()");
}

var string_split = $loader.loadprim("std@string_split", 2);

base_string.split = $varargs(function(args) {
		var sep;
		var arglen = $asize(args);
		if(arglen == 0)
		sep = " ";
		else if(arglen == 1) {
		sep = args[0];
		if($typeof(sep) == $tobject && has_field(sep, "@value"))
		sep = sep.@value;
		if($typeof(sep) != $tstring)
		$throw("Separator for split() must be a string, not " + $string(sep));
		}
		else
		$throw("Expected 0 or 1 arguments for string.split.");

		if($ssize(sep) == 0)
		return this.dice();

		var first = $new(null);
		var list = first;
		var pos = 0;
		var strlen = $ssize(this.@value);
		var temp = this.@value;
		var match_pos = 0;
		var sep_len = $ssize(sep);
		var matches = 0;
		while(pos < strlen) {
			match_pos = $sfind(temp, pos, sep);
			if(match_pos != null) {
				list.data = base_string.new($ssub(temp, pos, match_pos - pos));
				pos = match_pos + sep_len;
			}
			else {
				list.data = base_string.new($ssub(temp, pos, strlen - pos));
				pos = strlen;
			}
			matches = matches + 1;
			list.next = $new(null);	
			list = list.next;
		}

		var i = 0;
		var res = $amake(matches);
		list = first;
		while(i < matches) {
			res[i] = list.data;
			list = list.next;
			i = i + 1;
		}

		base_array.new(res);
})

base_string.dice = function() {
	var i = 0;
	var strlen = $ssize(this.@value);
	var res = $amake(strlen);
	while(i < strlen) {
		res[i] = this.__get(base_number.new(i));
		i = i + 1;
	}

	base_array.new(res);
}

var regexp_new = $loader.loadprim("regexp@regexp_new", 1);
base_regex = new_brat(null);
base_regex.@internal_regex = base_object.@@null;
base_regex.new = function(regx_string) {
	if($typeof(regx_string) == $tobject && has_field(regx_string, "@value"))
		regx_string = regx_string.@value;
	if($typeof(regx_string) != $tstring)
		$throw("Must create new regex with a string, not " + $string(regx_string));

	var reg = new_brat(this);
	reg.@internal_regex = regexp_new(regx_string);
	reg; 
}

var regexp_match = $loader.loadprim("regexp@regexp_match", 4);
base_regex.match = function(val) {
	if($typeof(val) == $tobject && has_field(val, "@value"))
		val = val.@value;
	else
		$throw("Wrong, wrong, wrong!");

	if(regexp_match(this.@internal_regex, val, 0, $ssize(val)))
		base_object.@@true;
	else
		base_object.@@false;
}

base_regex.@tilde = base_regex.match;

base_symbol = new_brat(null);
base_symbol.new = function(sym_string) {
	if($typeof(sym_string) == $tobject && has_field(sym_string, "@value"))
		sym_string = sym_string.@value;
	if($typeof(sym_string) == $tstring)
		sym_string = $hash(to_identifier(sym_string));
	else
		$throw("Must create new symbol with using a string or a symbol, not " + $string(sym_string));

	var sym = new_brat(this);
	sym.@value = sym_string;
	sym; 
}

base_symbol.@equal@equal = function(rhs) {
	if($typeof(rhs) == $tobject && has_field(rhs, "@value"))
		rhs = rhs.@value;

	if($typeof(rhs) != $tint)
		base_object.@@false;
	else if(this.@value == rhs)
		base_object.@@true;
	else
		base_object.@@false;		
}

base_symbol.@to_s = function() {
	$field(this.@value);
}

var to_id_list = $hnew(22);
$hset(to_id_list, "!", "@bang", null)
$hset(to_id_list, "*", "@star", null)
$hset(to_id_list, "-", "@minus", null)
$hset(to_id_list, "+", "@plus", null)
$hset(to_id_list, "||", "@oror", null)
$hset(to_id_list, "|",  "@or", null)
$hset(to_id_list, "&&", "@andand", null)
$hset(to_id_list, "&", "@and", null)
$hset(to_id_list, "@", "@at", null)
$hset(to_id_list, "~", "@tilde", null)
$hset(to_id_list, "^", "@up", null)
$hset(to_id_list, "/", "@forward", null)
$hset(to_id_list, "\\", "@back", null)
$hset(to_id_list, "?", "@question", null)
$hset(to_id_list, "<", "@less", null)
$hset(to_id_list, ">", "@greater", null)
$hset(to_id_list, "!=","@notequal", null)
$hset(to_id_list, "=", "@equal", null)
$hset(to_id_list, ">=", "@greater@equal", null)
$hset(to_id_list, "<=", "@less@equal", null)
$hset(to_id_list, "%", "@percent", null)
$hset(to_id_list, "_", "@under", null)
$hset(to_id_list, "$", "@dollar", null)

var from_id_list = $hnew(22);
$hset(from_id_list, "@bang", "!", null)
$hset(from_id_list, "@star", "*", null)
$hset(from_id_list, "@minus", "-", null)
$hset(from_id_list, "@plus", "+", null)
$hset(from_id_list, "@oror", "||", null)
$hset(from_id_list, "@or",  "|", null)
$hset(from_id_list, "@andand", "&&", null)
$hset(from_id_list, "@and", "&", null)
$hset(from_id_list, "@at", "@", null)
$hset(from_id_list, "@tilde", "~", null)
$hset(from_id_list, "@up", "^", null)
$hset(from_id_list, "@forward", "/", null)
$hset(from_id_list, "@back", "\\", null)
$hset(from_id_list, "@question", "?", null)
$hset(from_id_list, "@less", "<", null)
$hset(from_id_list, "@greater", ">", null)
$hset(from_id_list, "@notequal","!=", null)
$hset(from_id_list, "@equal", "=", null)
$hset(from_id_list, "@percent", "%", null)
$hset(from_id_list, "@under", "_", null)
$hset(from_id_list, "@dollar", "$", null)

to_identifier = function(string) {
	if($typeof(string) == $tobject && has_field(string, "@value")) {
		string = string.@value;
	}
	//String was a symbol, already escaped
	if($typeof(string) == $tint) {
		return $field(string);
	}
	if($typeof(string) != $tstring)
		$throw("Cannot convert " + $string(string) + " to an identifier.");

	var regexp1 = regexp_new("!=|>=|<=|\\|\\||[!?\\-*+^@~\\/\\\\><$_%|&=]");
	var f1 = function(m) { $hget(to_id_list, reg_matched(m), null) };
	string = reg_rep_fun(regexp1, string, f1);
	var regexp2 = regexp_new("\\b(true|false|if|then|else|do|while|break|continue|switch|default|null|var|try|catch|return|function|this)\\b");
	var f2 = function(m) { "@" + reg_matched(m) }
	reg_rep_fun(regexp2, string, f2);
}

from_identifier = function(string) {
	if($typeof(string) != $tstring)
		$throw("Cannot convert " + $string(string) + " to an identifier.");

	var regexp1 = regexp_new("@(bang|star|minus|plus|oror|or|andand|and|at|tilde|up|forward|back|question|less|greater|notequal|equal|percent|under|dollar)");

	var f1 = function(m) { $hget(from_id_list, reg_matched(m), null) };
	string = reg_rep_fun(regexp1, string, f1);
	var regexp2 = regexp_new("@(true|false|if|then|else|do|while|break|continue|switch|default|null|var|try|catch|return|function|this)");
	var f2 = function(m) { var s = reg_matched(m); $ssub(s, 1, $ssize(s) - 1); }
	reg_rep_fun(regexp2, string, f2);
}

var run_gc = $loader.loadprim("std@run_gc", 1);
var gc_stats = $loader.loadprim("std@gc_stats", 0);

base_object.memstats = function() {
	$print("Before running gc:", gc_stats(), "\n");
	run_gc(true);
	$print("After running gc:", gc_stats(), "\n");
}


$exports.hset = hset;
$exports.make_hash = make_hash;
$exports.new_brat = new_brat;
$exports.has_field = has_field;
$exports.base_array = base_array;
$exports.base_hash = base_hash;
$exports.base_number = base_number;
$exports.base_string = base_string;
$exports.base_object = base_object;
$exports.base_regex = base_regex;
$exports.base_symbol = base_symbol;
$exports.num_args = num_args;
$exports.memstats = memstats;
$exports.nice_identifier = from_identifier;
$exports.to_identifier = to_identifier;
$exports.brat_var_args = $loader.loadprim("core-util@brat_var_args", 1);
