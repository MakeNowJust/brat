includes 'parser/walker' 'parser/sexp' 'parser/env' 'parser/compiler_helper'

c = walker.new
c.squish compiler_helper

c.init = { ast |
  my.ast = ast
  my.env = env.new
}

c.prototype.compile = {
  "#{file_header}
  _exports = {}
  local _main = function()
    #{method_header}

    setfenv(1, {})

    #{inner_brat}
  end

  local _result = coxpcall(_main, exception._handler)
  if not _lib then
    if not _result then
      os.exit(-1)
    else
      os.exit(0)
    end
  end
  "
}

c.file_header = "
  require \"coxpcall\"
  local _lib
  if package.loaded.core then
    _lib = true
  else
    _lib = false
    require \"core\"
  end
  "

c.method_header = "
  local object = object
  local array = array
  local number = number
  local string = base_string
  local exception = exception
  local hash = hash
  local regex = regex
  local _self = object
  local _type = type
  local _error = error
  local _tostring = tostring
  local brat_function = brat_function
  local _lifted_call = _lifted_call
  local _rawget = rawget
  "

c.walk :program { node |
  c = my
  results = node.nodes.map({ n |
    c.process(n).out
  }).join("\n")
}


c.walk :local_var_assign { node |
  temp = my.env.new_var node.lhs
  rhs = process node.rhs, temp
  my.env.set_type temp, rhs[:type]
  true? temp == rhs.var
  { r temp, "local #{temp}\n#{rhs.out}" }
  { r temp, "#{rhs.out}\nlocal #{temp} = #{rhs.var}" }
}

var_reassign = { node |
  rhs = process node.rhs
  temp = my.env[node.lhs]
  my.env.set_type temp, rhs[:type]
  r temp, "#{rhs.out}\n#{temp} = #{rhs.var}"
}

c.walk :local_var_reassign, ->var_reassign
c.walk :upvar_assign, ->var_reassign

c.walk :field_assign { node, var = null |
  lhs = process node.lhs.target
  var = node.lhs.field
  rhs = process node.rhs

  out = lhs.out << "\n" << rhs.out << "
    if _type(#{lhs.var}) == 'table' then
      #{lhs.var}['#{var}'] = #{rhs.var}
    else
      _error('Cannot set method on ' .. #{lhs.var})
    end
    "

  r rhs.var, out
}

get_a_value = { node, var = null |
  res = set_result var
  res.out << get_local_value(node.value, res.var)
  res
}

c.walk :get_local_value, ->get_a_value
c.walk :get_up_value, ->get_a_value

c.walk :get_value { node, var = null |
  res = set_result var
  res.out << get_value(node.value, res.var)
  r res
}

invoke = { node, invoke_meth, var = null |
  res = set_result var
  w = my
  args = node.args.map { n | w.process n }
  res.out << args.map({ a | a.out }).join("\n")
  res.out << invoke_meth node.method, args.map({ a | a.var }), var
  r res
}

c.walk :invoke_local { node, var = null |
  invoke node, ->invoke_local, var
}

c.walk :invoke_self { node, var = null |
  invoke node, ->invoke_self, var
}

c.walk :number { node |
  val = node.value.to_s
  r val, '', type: :number
}

c.walk :array { node, var = null |
  true? node.nodes.empty?
    {
      res = set_result var, "array:new()"
      r res.var, res.out, type: :array
    }
    {
      res = set_result var
      ares_var = res.var
      temp_var = my.env.next_temp
      out = "#{res.out}\ndo\nlocal #{temp_var}\n#{ares_var} = {}\n"
      comp = my

      node.nodes.each_with_index { n, i |
        elem = comp.process n, temp_var
        out << elem.out << "\n" <<
          "#{ares_var}[#{i + 1}] = #{elem.var}\n"
      }

      out << "#{ares_var} = array:new(#{ares_var})\nend\n"

      r ares_var, out, type: :array
    }
}

c.walk :hash { node, var = null |
  true? node.nodes.empty?
    {
      res = set_result var, "hash:new()"
      r res.var, res.out, type: :hash
    }
    {
      res = set_result var, "{}"
      hres_var = res.var
      key_temp = my.env.next_temp
      val_temp = my.env.next_temp

      out = "#{res.out}\ndo\nlocal #{key_temp};local #{val_temp}\n"

      w = my
      node.nodes.each { pair |
        key = w.process pair.first, key_temp
        val = w.process pair.last, val_temp

        out << "#{key.out}\n#{val.out}\n#{hres_var}[#{key.var}] = #{val.var}"
      }

      my.env.unset key_temp
      my.env.unset val_temp

      out << "\n#{hres_var} = hash:new(#{hres_var})\nend\n"

      r hres_var, out, type: :hash
    }
}

c.walk :string { node, var = null |
  true? node.nodes.empty?
    {
      res = set_result var, 'string:new("")'
      r res.var, res.out, type: :string
    }
    {
      res = set_result var, "string:new(\"#{node.value}\")"
      r res.var, res.out, type: :string
    }
}

c.prototype.do_args = { node |
  w = my
  out = ""
  args = node.args.map({ n | w.process(n) })
  arg_list = args.map({ a | a.var }).join(", ")

  true? arg_list.empty?
    { arg_list = "_self" }
    { arg_list = "_self, " << arg_list }

  required = args.select({ n | n[:arg_type] == :arg })
  default = args.select({ n | n[:arg_type] == :def_arg })
  optional = args.select({ n | n[:arg_type] == :var_arg })

  true? all_required = (default.empty? && { optional.empty? })
    { arg_list << ", _too_many_" }

  true? all_required
    {
      out << "
        if _too_many_ then
          _error(exception:argument_error('function', #{required.length}, 'too many'))
        end
      "
    }

  required.each_with_index { n, i |
    out << "
      if #{n.var} == nil then
        _error(exception:argument_error('function', #{i + 1}, #{i}))
      end
    "
  }

  default.each { n |
    out << n.out
  }

  optional.each { n |
    out << n.out
  }

  [ arg_list: arg_list, out: out ]
}

c.walk :function { node, var = null |
  w = my

  args = do_args node

  res = set_result var, "function(#{args[:arg_list]})"
  res.out << args[:out]

  body = node.body.copy
  last = body.pop

  body_res = body.map({ n | w.process(n, '_dummy').out }).join("\n")
  res.out << body_res

  true? last
   {
     last_res = my.process last, "_return_"
     res.out << last_res.out << "\n"
     false? last_res.var == '_return_'
       { res.out << "return #{last_res.var}\n" }
   }

  res.out << "\nend\n"

  r res.var, res.out, type: :function
}

c.walk :arg { node, var = null |
  temp = my.env.new_var node.id
  r temp, '', arg_type: :arg
}

c.walk :var_arg { node, var = null |
  temp = my.env.new_var node.id
  r '...', "local #{temp} = array:new(...)\n", arg_type: :var_arg
}

c.walk :def_arg { node, var = null |
  temp = my.env.new_var node.id
  rhs = process node.value, temp
  out = "
    if #{temp} == nil then
      #{rhs.out}
  "

  false? rhs.var == temp
    { out << "#{temp} = #{rhs.var}\n" }

  out << "end\n"

  r temp, out, arg_type: :def_arg
}

export c, :compiler
