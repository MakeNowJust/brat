includes 'parser/walker' 'parser/sexp' 'parser/env'

c = walker.new

c.init = { ast |
  my.ast = ast
  my.env = env.new
}

c.prototype.compile = {
  "#{file_header}
  _exports = {}
  local _main = function()
    #{method_header}

    setfenv(1, {})

    #{inner_brat}
  end

  local _result = coxpcall(_main, exception._handler)
  if not _lib then
    if not _result then
      os.exit(-1)
    else
      os.exit(0)
    end
  end
  "
}

c.file_header = "
  require \"coxpcall\"
  local _lib
  if package.loaded.core then
    _lib = true
  else
    _lib = false
    require \"core\"
  end
  "

c.method_header = "
  local object = object
  local array = array
  local number = number
  local string = base_string
  local exception = exception
  local hash = hash
  local regex = regex
  local _self = object
  local _type = type
  local _error = error
  local _tostring = tostring
  local brat_function = brat_function
  local _lifted_call = _lifted_call
  local _rawget = rawget
  "


c.prototype.r = { result_var, output, extras = null |
  o = object.new
  o.var = result_var
  o.output = output
  o.extras = extras
  o
}

c.walk :program { node |
  c = my
  results = node.nodes.map({ n |
    true? sexp?(n)
      { c.process n }
      { "" }
  })

  results.map(:output).join("\n")
}

c.walk :local_var_assign { node |
  rhs = process node.rhs
  temp = my.env.new_var node.lhs
  r temp, "local #{temp} = #{rhs.var}"
}

var_reassign = { node |
  rhs = process node.rhs
  temp = my.env[node.lhs]
  r temp, "#{temp} = #{rhs.var}"
}

c.walk :local_var_reassign, ->var_reassign
c.walk :upvar_assign, ->var_reassign

c.walk :number { node |
  val = node.value.to_s
  r val, val
}

export c, :compiler
