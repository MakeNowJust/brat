includes 'parser/walker' 'parser/sexp' 'parser/env' 'parser/compiler_helper'

c = walker.new
c.squish compiler_helper

c.init = { ast |
  my.ast = ast
  my.env = env.new
}

c.prototype.compile = {
  "#{file_header}
  _exports = {}
  local _main = function()
    #{method_header}

    setfenv(1, {})

    #{inner_brat}
  end

  local _result = coxpcall(_main, exception._handler)
  if not _lib then
    if not _result then
      os.exit(-1)
    else
      os.exit(0)
    end
  end
  "
}

c.file_header = "
  require \"coxpcall\"
  local _lib
  if package.loaded.core then
    _lib = true
  else
    _lib = false
    require \"core\"
  end
  "

c.method_header = "
  local object = object
  local array = array
  local number = number
  local string = base_string
  local exception = exception
  local hash = hash
  local regex = regex
  local _self = object
  local _type = type
  local _error = error
  local _tostring = tostring
  local brat_function = brat_function
  local _lifted_call = _lifted_call
  local _rawget = rawget
  "

c.walk :program { node |
  c = my
  results = node.nodes.map({ n |
    true? sexp?(n)
      { c.process n }
      { "" }
  })

  results.map(:output).join("\n")
}

c.walk :local_var_assign { node |
  temp = my.env.new_var node.lhs
  rhs = process node.rhs, temp
  my.env.set_type temp, rhs[:type]
  true? temp == rhs.var
  { r temp, "local #{temp}\n#{rhs.output}" }
  { r temp, "#{rhs.output}\nlocal #{temp} = #{rhs.var}" }
}

var_reassign = { node |
  rhs = process node.rhs
  temp = my.env[node.lhs]
  my.env.set_type temp, rhs[:type]
  r temp, "#{rhs.output}\n#{temp} = #{rhs.var}"
}

c.walk :local_var_reassign, ->var_reassign
c.walk :upvar_assign, ->var_reassign

c.walk :get_local_value { node, var = "_dummy_" |
  r var, get_local_value(node.value, var)
}

c.walk :number { node |
  val = node.value.to_s
  r val, '', type: :number
}

c.walk :array { node, var = null |
  true? node.nodes.empty?
    {
      res = set_result var, "array:new()"
      r res.var, res.out, type: :array
    }
    {
      res = set_result var
      ares_var = res.var
      temp_var = my.env.next_temp
      out = "#{res.out}\ndo\nlocal #{temp_var}\n#{ares_var} = {}\n"
      comp = my

      node.nodes.each_with_index { n, i |
        elem = comp.process n, temp_var
        out << elem.output << "\n" <<
          "#{ares_var}[#{i + 1}] = #{elem.var}\n"
      }

      out << "#{ares_var} = array:new(#{ares_var})\nend\n"

      r ares_var, out, type: :array
    }
}

c.walk :hash { node, var = null |
  true? node.nodes.empty?
    {
      res = set_result var, "hash:new()"
      r res.var, res.out, type: :hash
    }
    {
      res = set_result var, "{}"
      hres_var = res.var
      key_temp = my.env.next_temp
      val_temp = my.env.next_temp

      out = "#{res.out}\ndo\nlocal #{key_temp};local #{val_temp}\n"

      w = my
      node.nodes.each { pair |
        key = w.process pair.first, key_temp
        val = w.process pair.last, val_temp

        out << "#{key.output}\n#{val.output}\n#{hres_var}[#{key.var}] = #{val.var}"
      }

      my.env.unset key_temp
      my.env.unset val_temp

      out << "\n#{hres_var} = hash:new(#{hres_var})\nend\n"

      r hres_var, out, type: :hash
    }
}

c.walk :string { node, var = null |
  true? node.nodes.empty?
    {
      res = set_result var, 'string:new("")'
      r res.var, res.out, type: :string
    }
    {
      res = set_result var, "string:new(\"#{node.value}\")"
      r res.var, res.out, type: :string
    }
}

export c, :compiler
