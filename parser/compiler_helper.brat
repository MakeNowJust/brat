h = object.new

h.callable? = { name |
  "_type(#{name}) == \"function\" or (_type(#{name}) == \"table\" and _rawget(#{name}, \"__call_thing\"))"
}

h.get_local_value = { name, res_var |
  temp = my.env[name]

  action = true? res_var
            { "#{res_var} = " }
            { "return " }

  call_it = "#{action} #{temp}(_self)\n"

  t = my.env.get_type temp

  true? t
   {
    true? t == :function
      { call_it }
      {
        true? res_var
          { my.env.set_type res_var, t }

        "#{action} #{temp}\n"
      }
   }
   {
    "
    if #{callable? temp} then
      #{call_it}
    elsif #{temp} then
      #{action} #{temp}
    else
      _error(exception:name_error(\"#{name}\"))
    end
    "
  }
}

h.set_result = { var = null, initial = null |
  res = object.new
  res.out = ''
  res.var = var

  null? res.var
    { res.var = my.env.next_unset }

  null? res.var
    {
      res.var = my.env.next_var
      res.out = true? initial
              { "local #{res.var} = #{initial}\n" }
              { "local #{res.var}\n" }
    }
    {
      true? initial
        { res.out = "#{res.var} = #{initial}\n" }
    }

  res
}

h.r = { result_var, output, extras = [:] |
  o = object.new
  o.var = result_var
  o.output = output
  o.get = { v | extras[v] }
  o
}

export h, :compiler_helper
