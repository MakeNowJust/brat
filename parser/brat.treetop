grammar BaseBrat

  #Wrap up program
  rule program
 	line+ {
		def brat(res_var = nil)
			<<-LUA
			require "core/core"
			local object = object
			local array = array
			local number = number
			local string = base_string
			local exception = exception
			local hash = hash
			local regex = regex
			local _self = object
			#{self.inner_brat}
			LUA
		end

		def inner_brat
			Treetop::Runtime::SyntaxNode.clear_variables
			elements.map {|e| "   " << e.brat if e.respond_to? :brat }.compact.join("\n")
		end
	}
	/
	eof
  end

  #Matches a single expression, comment, or an empty line
  rule line
	~comment 
	/
 	~(space?) e:expression ~(space?) ~(comment?) ~( eof / eol / eob)  {
		def brat(res_var = nil)
			if e.respond_to? :brat
				e.brat
			end
		end

		def result
			e.result
		end
	}
	/
	~empty_line
  end

  #Matches an empty line
  rule empty_line
  	space? ~eol {
		def brat(res_var = nil)
			""
		end
	}
  end

  #Expressions! Which is basically everything
  rule expression
	regex / binary_operation / index_set / index_get / 
	assignment / 
	paren_exp ~(!("." / "(")) { 
		def brat(res_var = nil)
			paren_exp.brat
		end 

		def no_result_brat
			paren_exp.no_result_brat
		end
	}
	/ 
	unary_operation / method_access / method_invocation / number / string / symbol / function_definition / array / hash 
  end

  #Expressions which can be followed by []
  rule indexed_expression
 	array / hash / paren_exp / unary_operation / method_invocation / string
  end

  #Expressions which can be used as lhs of "." method calls
  rule method_target_expression
 	array / hash / paren_exp / number / string / regex / symbol / unary_operation
  end
 
  #Expressions which can be used as the lhs of a binary expression 
  rule binary_lhs_expression
	method_with_parens / index_get / paren_exp / number / string / array / hash / regex / symbol / unary_operation / method_invocation
  end

  rule unary_rhs_expression
 	index_get / paren_exp / number / string / array / hash / method_invocation / regex / symbol
  end

  rule default_arg_rhs_expression
	index_get / paren_exp / method_access / method_invocation / number / unary_operation / string / symbol / function_definition / array / hash
  end

  #Matches regular expression literals
  rule regex
	"/" r:(!"/" . / "\\/")* "/" {
		def brat(res_var = nil)
			if res_var
				@result = res_var
				"#@result = regex:new(\"#{r.text_value}\")\n"
			else
				next_temp
				"local #@result = regex:new(\"#{r.text_value}\")\n"
			end
		end
	}
  end

  #Matches comments
  rule comment
  	space? "#*" (!"*#" (comment / .))* "*#" {
		def brat(res_var = nil)
			""
		end
	}
	/
	space? "#" (!(eol/eof) .)* {
		def brat(res_var = nil)
			""
		end
	}
  end

  #Matches hash table literals
  rule hash
	"[" space? ":" space? "]" {
		def brat(res_var = nil)
			@result = res_var || next_temp
			if res_var
				"@#result = hash:new()" 
			else
				"local @#result = hash:new()" 
			end
		end
	}
	/
  	"[" spaceorbreak hash_inner spaceorbreak "]" {
		def brat(res_var = nil)
			output = hash_inner.brat(res_var)
			@result = hash_inner.result
			output
		end
	}
  end

  #Matches array literals
  rule array
  	"[" spaceorbreak array_inner spaceorbreak "]" {
		def brat(res_var = nil)
			inner = array_inner.brat
			@result = array_inner.result
			"local #@result \ndo\n" <<
				inner <<
				"end\n" <<
				"#@result = array:new(#{array_inner.result})\n"
		end
	}
	/
	"[" spaceorbreak "]" {
		def brat(res_var = nil)
			next_temp
			"local #@result = array:new()\n"
		end
	}
  end

  rule array_inner
	first:expression rest:(((spaceorbreak "," spaceorbreak) / ( space / eol)+) e:expression)* {
		def brat(res_var = nil)
			temp_var = next_temp
			next_temp
			output = "#@result = {}\ndo\n" <<
				"local #{temp_var}\n" <<
				first.brat(temp_var) << "\n" <<
				"#@result[1] = #{first.result}\n"

			rest.elements.each_with_index do |r, i|
				output << r.e.brat(temp_var) << "\n" <<
					"#@result[#{i + 2}] = #{r.e.result}\n"
			end

			output << "end\n"
		end
	}
  end

  #Inside of a hash literal
  rule hash_inner
	first:hash_argument rest:(((spaceorbreak "," spaceorbreak) / (space / eol)+) n:hash_argument)* {
		def brat(res_var = nil)
			key_temp = next_temp
			val_temp = next_temp
			@result = res_var || next_temp
			output = "local #@result = {}\n do \n" <<
				"local #{key_temp}\nlocal #{val_temp}\n" <<
				first.brat(key_temp, val_temp) <<
				"#@result[#{first.index}] = #{first.value}\n"

			rest.elements.each do |e|
				elem = e.n
				output << elem.brat(key_temp, val_temp) << "\n" <<
					"#@result[#{elem.index}] = #{elem.value}\n"
			end

			output << "#@result = hash:new(#@result)\nend\n"
		end
	}
  end

  #Single member of a hash table
  rule hash_argument
	i:((identifier / operator) (identifier / operator / number)*) ":" spaceorbreak e:expression {
		attr_reader :index, :value

		def brat(key_temp, val_temp)
			output = e.brat(val_temp)
			@index = "string:new(\"#{i.text_value}\")"
			@value = e.result
			output
		end
	}
	/
  	i:expression spaceorbreak ":" spaceorbreak v:expression {
		attr_reader :index, :value
		def brat(key_temp, val_temp)
			output = i.brat(key_temp) << "\n" << v.brat(val_temp) << "\n"
			@index = i.result
			@value = v.result
			output
		end
	}
  end

  #Setting value via index (e.g., "a[1] = b")
  rule index_set
  	a:indexed_expression "[" i:expression "]" space? "=" spaceorbreak v:expression {
		def brat(res_var = nil)
			next_temp
			v.brat << "\n" << 
				a.brat << "\n" << 
				i.brat << "\n" << 
				"local #@result = #{a.result}:set(#{i.result}, #{v.result})\n"
		end
	}
  end

  #Retrieving value via index (e.g., "a[1]")
  rule index_get
  	e:indexed_expression a:("[" inner_arg_list "]")+ !"." args:arg_list {
		def brat(res_var = nil)
			@result = res_var || next_temp
			output = "local #@result\ndo\n" <<
				e.brat << "\n" <<
				"#@result = #{e.result}\n"

			a.elements.each do |elem|
				output << elem.inner_arg_list.brat << "\n" <<
					"#@result = #@result:get(#{elem.inner_arg_list.list})\n" 
			end

			unless args.respond_to? :nothing?
				output << args.brat << "\n" <<
					invoke(@result, @result, args.list, args.length) << "\n"
			end

			output << "end\n"
		end
	}
  end

  #Matches assignment using "=" operator
  rule assignment
 	lhs:field_access space "=" spaceorbreak rhs:(function_definition / method_access) {
		def brat(res_var = nil)
			output = lhs.brat << "\n" << rhs.brat << "\n"	
			lhs_result = lhs.result
			rhs_result = rhs.result
			@result = rhs.result

			output << <<-LUA
				if type(#{lhs_result}) == "table" then
					#{lhs_result}["#{lhs.i.brat}"] = #{rhs_result}
				elseif type(#{lhs_result}) == "number" then
					number["#{lhs.i.brat}"] =  #{rhs_result}
				else
					error("Cannot set method on " .. #{lhs_result})
				end
			LUA
		end
	}
	/
 	lhs:field_access space "=" spaceorbreak rhs:expression {
		def brat(res_var = nil)
			output = lhs.brat << "\n" << rhs.brat << "\n"	
			lhs_result = lhs.result
			rhs_result = rhs.result
			@result = rhs.result

			output << <<-LUA
				if type(#{lhs_result}) == "table" then
					#{lhs_result}["#{lhs.i.brat}"] = function () return #{rhs_result} end
				elseif type(#{lhs_result}) == "number" then
					number["#{lhs.i.brat}"] = function () return #{rhs_result} end
				else
					error("Cannot set method on " .. #{lhs_result})
				end
			LUA
		end
	}
	/
	lhs:identifier space "=" spaceorbreak rhs:expression {
		def brat(res_var = nil)
			var = lhs.brat
			temp = var_exist? var
			if temp
				output = rhs.brat << "\n#{temp} = #{rhs.result}\n"
			else
				temp = var_add var
				output = "local #{temp}\n" <<
					 rhs.brat(temp) << 
					"\n#{temp} = #{rhs.result}\n"
			end
			@result = temp
			output
		end
	}
  end

  #Matches a lhs that is a field access (e.g., "a.b")
  rule field_access
  	m:method_chain i:(identifier / operator) {
		def brat(res_var = nil)
			m.brat
		end

		def result
			m.result
		end
	}
  end

  #Matches a parenthesized expression
  rule paren_exp
  	'(' ~(space?) expression ~(space?) ')' {
		def brat(res_var = nil)
			output = expression.brat
			@result = expression.result
			output
		end

		def no_result_brat
			if expression.respond_to? :no_result_brat
				expression.no_result_brat
			else
				expression.brat
			end
		end
	}
  end

  #Matches an identifier, which is any letterfollowed by letters, digits,
  #and some symbols.
  #Also mangles anything that is a Lua keyword.
  rule identifier
	[a-zA-Z] (!"->" !space [a-zA-Z0-9_!?\-*+^&@~/\\><$_%])* {
		def brat(res_var = nil)
			escape_identifier text_value
		end
	}
  end

  #Matches a number
  rule number
  	float / integer 
  end

  #Matches floats
  rule float
	'-'? [0-9]+ "." [0-9]+ {
		def brat(res_var = nil)
			@result = text_value
			""
		end
	}
  end

  #Matches integers

  rule integer
	'-'? [0-9]+ {
		def brat(res_var = nil)
			@result = text_value
			""
		end
	}
  end

  #Matches doubly-quoted strings
  rule string
    '"' content:((string_interpolation / '\"' / !'"' . )*) '"' {
		def brat(res_var = nil)
			@result = res_var || next_temp
			if content.elements.empty?
				if res_var
					"#@result = string:new(#{text_value});"
				else
					"local #@result = string:new(#{text_value});"
				end
			else
				output = ""
				text = '"'
				content.elements.each do |e|
					if e.respond_to? :brat
						output << e.brat << "\n"
						text << "\" .. tostring(#{e.result}) .. \""
					else
						text << e.text_value
					end
				end

				if res_var
					output << "#@result = string:new(#{text << '"'})\n"
				else
					output << "local #@result = string:new(#{text << '"'})\n"
				end
			end
		end
	}
	/
	"'" content:(("\\'" / "\\\\" / !"'" . )*) "'" {
		def brat(res_var = nil)
			@result = res_var || next_temp
			string = content.text_value.gsub("\\'", "'").gsub(/\\([^\\])/, "\\\\\\\\\\1").gsub('"', '\\"')
			if res_var
				"#@result = string:new(\"#{string}\")\n"
			else
				"local #@result = string:new(\"#{string}\")\n"
			end
		end
	}
  end

  rule string_interpolation
	~"#" "{" ~(space?) first:expression? ~(space?) rest:((~eol ~(space?) expression ~(space?))*) ~(eol?) ~(space?) ~"}" {
		def brat(res_var = nil)
			output = ""
			if first.respond_to? :brat
				output << first.brat
				@result = first.result
			end

			rest.elements.each do |e|
				if e.expression.respond_to? :brat
					output << e.expression.brat
					@result = e.expression.result
				end
			end

			output
		end

		def check_variables
			first.check_variables
			rest.elements.each do |e|
				e.expression.check_variables
			end
		end

	} 
  end

  #Like symbols in Scheme or Ruby
  rule symbol
	":" id:(identifier / operator / number)+ {
		def brat(res_var = nil)
			if res_var
				@result = res_var
				"#@result = string:new(\"#{id.text_value}\")\n"
			else
				next_temp
				"local #@result = string:new(\"#{id.text_value}\")\n"
			end
		end
	} 
  end

  rule symbol_convert
	identifier
	/
	operator
	/
	number {
		def brat(res_var = nil)
			n.text_value
		end
	}
  end

  #Matches function definitions
  rule function_definition
	"{" space? fa:formal_args space? l:line* space? "}" {
		def brat(res_var = nil)
			new_scope
			if fa.respond_to? :brat
				args = fa.brat
			else
				args = "_self"
			end

			if fa.respond_to? :function_header
				inside = fa.function_header
			else
				inside = ""
			end
		
			output = ""

			elements = l.elements.map {|e| e.brat }

			unless elements.empty?
				l.elements.reverse_each do |e|
					if e.result
						elements << "return #{e.result}\n"
						break
					end
				end
			end

			inner_function = elements.join("\n");

			#Empty functions should return null object instead of Lua null
			if inner_function.strip.gsub(";", "").length == 0
				inner_function = "return object:null()\n"
			end

			next_temp

			#Have to check for when there are no formal arguments
			if fa.respond_to? :max
				max = fa.max
				min = fa.min
			else
				max = 0
				min = 0
			end

			output << <<-LUA
				local #@result = function (#{args})
					#{inside}
					#{inner_function}
				end
			LUA

			pop_scope

			output
		end
	}
  end

  #Matches formal arguments in a function definition
  rule formal_args
	space? plain_formals space? "|" !"|" {
		attr_reader :max, :min

		def brat(res_var = nil)
			plain_formals.brat
		end

		def function_header
			output = ""
			plain_formals.args.each do |a|
				output << "local #{var_exist? a} = #{a}\n"
			end
			@max = plain_formals.args.length
			@min = @max
			output
		end

		def check_variables
			plain_formals.check_variables
		end
	}
	/
	space? default_args space? "|" !"|" {
		attr_reader :var_args, :max, :min

		def brat(res_var = nil)
			"@args"	
		end

		def function_header name = "function"
			default_args.brat

			@max = default_args.args.length
			@min = 0

			output = "var @arg_len = $asize(@args);" <<
				"if(@arg_len > #{default_args.args.length})" <<
					"$throw(exception.argument_error(\"function\", \"up to #{default_args.args.length}\"));"

			#Check and set default args
			names = default_args.arg_names
			names.each do |n|
				unless n.match /\[\d+\]/
					output << "var #{n};"
				end
			end
			i = default_args.args.length
			default_args.args.reverse.each do |a|
				output << "if(@arg_len < #{i}) {\n #{a}\n"
				i -= 1
			end
			output << ("}" * default_args.args.length) << "\n"

			#Set args passed in
			output << "switch @arg_len {\n"

			num_names = names.length
			num_names.times do |l|
				output << "#{num_names - l} => {"
				names[0, num_names - l].each_with_index do |n, i|
					output << "#{n} = @args[#{i}];"
				end
				output << "}\n"
			end
			output << "}\n"


		end
	}
	/
	space? variable_args space? "|"	!"|" {
		attr_reader :var_args, :max, :min

		def brat(res_var = nil)
			param = variable_args.i.brat
			@param = var_add param
			@min = -1
			@max  = -1
			"@args"
		end

		def function_header
			"#{@param} = @brat.base_array.new(@args);\n"
		end

		def check_variables
			var_add variable_args.i.brat
		end
	}
	/
	space? plain_formals space? "," space? variable_args space? "|"	!"|"  {
		attr_reader :var_args, :max, :min

		def brat(res_var = nil)
			param = variable_args.i.brat
			@param = var_add param
		
			"@args"
		end

		def function_header
			plain_formals.brat
			req_args = plain_formals.args.length
			@min = req_args
			@max = -1
			i = 0
			output = "if($asize(@args) < #{req_args}) $throw(exception.new(\"function\", \"at least #{req_args}\"));\n"

			plain_formals.args.each do |a|
				if var_used? a
					output << "#{var_exist? a} = @args[#{i}];\n"
				else
					output << "var #{var_exist? a} = @args[#{i}];\n"
				end
				i += 1
			end

			output << "#{@param} = @brat.base_array.new($asub(@args, #{i}, $asize(@args) - #{i}));" 
		end

		def check_variables
			plain_formals.check_variables
			var_add variable_args.i.brat
		end
	}
	/
	space? default_args space? "," space? variable_args space? "|" !"|" {
		attr_reader :var_args, :max, :min

		def brat(res_var = nil)
			param = variable_args.i.brat
			@param = var_add param

			"@args"
		end

		def function_header
			default_args.brat
			@min = 0
			@max = -1
			output = "var @arg_len = $asize(@args);\n"

			#Check and set default args
			names = default_args.arg_names
			names.each do |n|
				unless n.match /\[\d+\]/
					output << "var #{n};"
				end
			end
			i = default_args.args.length
			default_args.args.reverse.each do |a|
				output << "if(@arg_len < #{i}) {\n #{a};\n"
				i -= 1
			end

			output << ("}" * default_args.args.length) << "\n"

			#Set args passed in
			output << "switch @arg_len {\n"

			num_names = names.length
			num_names.times do |l|
				output << "#{num_names - l} => {"
				names[0, num_names - l].each_with_index do |n, i|
					output << "#{n} = @args[#{i}];"
				end
				output << "}\n"
			end
		
			#This is if there are more args than defaults
			output << "default => { "
			names.each_with_index do |n, i|
				output << "#{n} = @args[#{i}];"
			end
			output << "}\n"

			#Close switch statement
			output << "}\n"

			output << "if(@arg_len > #{num_names}) {" <<
				"#{@param} = @brat.base_array.new($asub(@args, #{num_names}, $asize(@args) - #{num_names}));" <<
				"} else { #{@param} = @brat.base_array.new();}"
		end

		def check_variables
			var_add variable_args.i.brat
			default_args.check_variables
		end
	}
	/
	space? plain_formals space? "," space? default_args space? "," space? variable_args space? "|" !"|" {
		attr_reader :var_args, :max, :min

		def brat(res_var = nil)
			param = variable_args.i.brat
			@param = var_add param

			"@args"
		end

		def function_header
			plain_formals.brat
			default_args.brat
			def_args = default_args.args.length
			req_args = plain_formals.args.length
			@min = req_args
			@max = -1
			output = "var @arg_len = $asize(@args);" <<
				"if($asize(@args) < #{req_args}) $throw(exception.argument_error(\"function\", \"at least #{req_args}\"));"

			i = 0
			plain_formals.args.each do |a|
				if var_used? a
					output << "#{var_exist? a} = @args[#{i}];\n"
				else
					output << "var #{var_exist? a} = @args[#{i}];\n"
				end
				i += 1
			end

			#Check and set default args
			names = default_args.arg_names
			names.each do |n|
				unless n.match /\[\d+\]/
					output << "var #{n};"
				end
			end

			i = def_args
			default_args.args.reverse.each do |a|
				output << "if(@arg_len < #{i + req_args}) {\n #{a};\n"
				i -= 1
			end

			output << ("}" * default_args.args.length) << "\n"

			#Set args passed in
			output << "switch @arg_len {\n"

			num_names = names.length
			num_names.times do |l|
				output << "#{num_names - l + req_args} => {"
				names[0, num_names - l].each_with_index do |n, i|
					output << "#{n} = @args[#{i + req_args}];"
				end
				output << "}\n"
			end
			
			#This is if there are more args than defaults
			output << "default => { if(@arg_len > #{req_args + def_args}) {"
			names.each_with_index do |n, i|
				output << "#{n} = @args[#{i + req_args}];"
			end
			output << "}}\n"

			#Close switch statement
			output << "}\n"

			other_args = def_args + req_args
			output << "if(@arg_len > #{other_args}) {" <<
				"#{@param} = @brat.base_array.new($asub(@args, #{other_args}, $asize(@args) - #{other_args}));" <<
				"} else { #{@param} = @brat.base_array.new();}"
		end
	}
	/
  	space? plain_formals space? "," space? default_args space? "|" !"|" {
		attr_reader :var_args, :max, :min

		def brat(res_var = nil)
			"@args"
		end

		def function_header
			plain_formals.brat
			default_args.brat
			def_args = default_args.args.length
			req_args = plain_formals.args.length
			@max = def_args + req_args
			@min = req_args
			output = "var @arg_len = $asize(@args);" <<
				"if($asize(@args) < #{req_args}) $throw(exception.argument_error(\"function\", \"at least #{req_args}\"));\n" <<
				"if(@arg_len > #{def_args + req_args})" <<
					"$throw(exception.argument_error(\"function\", \"up to #{def_args + req_args}\"));"

			i = 0
			plain_formals.args.each do |a|
				if var_used? a
					output << "#{var_exist? a} = @args[#{i}];\n"
				else
					output << "var #{var_exist? a} = @args[#{i}];\n"
				end
				i += 1
			end

			#Check and set default args
			names = default_args.arg_names
			names.each do |n|
				unless n.match /\[\d+\]/
					output << "var #{n};"
				end
			end
			i = def_args
			default_args.args.reverse.each do |a|
				output << "if(@arg_len < #{i + req_args}) {\n #{a};\n"
				i -= 1
			end

			output << ("}" * default_args.args.length) << "\n"

			#Set args passed in
			output << "switch @arg_len {\n"

			names = default_args.arg_names
			num_names = names.length
			num_names.times do |l|
				output << "#{num_names - l + req_args} => {"
				names[0, num_names - l].each_with_index do |n, i|
					output << "#{n} = @args[#{i + req_args}];"
				end
				output << "}\n"
			end
			#Close switch statement
			output << "}\n"
		end
	}
	/
	!"|"
  end

  rule plain_formals
	i:identifier rest_formal {
		attr_reader :args

		def brat(res_var = nil)
			name = i.brat
			var_add name
			@args = [name] + rest_formal.brat
			(["_self"] + @args).join(", ")
		end

		def check_variables
			var_add i.brat
			rest_formal.check_variables
		end
	}
  end

  #Matches list items in a formal argument list
  rule rest_formal
  	(space? "," space? identifier ~(!(space "=")))* {
		def brat(res_var = nil)
			if elements.length > 0
				elements.map do |e|
					name = e.identifier.brat
					var_add name
					name
				end
			else
				[]
			end
		end

		def check_variables
			elements.each do |e|
				var_add e.identifier.brat
			end
		end
	}
  end

  rule default_args
	first:default_arg rest:(space? "," space? default_arg)* {
		attr_reader :args, :arg_names

		def brat(res_var = nil)
			@args = [first.brat]
			@arg_names = [first.var_name]
			rest.elements.each do |e|
				@args << e.default_arg.brat
				@arg_names << e.default_arg.var_name
			end
			""
		end

		def check_variables
			first.check_variables
			rest.elements.each do |e|
				e.default_arg.check_variables
			end
		end
	}
  end

  rule default_arg
	i:identifier space "=" space v:default_arg_rhs_expression {
		def brat(res_var = nil)
			@var_name = i.brat
			var_add @var_name
			"#{var_name} = { #{v.brat} };"
		end

		def var_name
			var_exist?(@var_name) || @var_name
		end

		def check_variables
			var_add i.brat
			v.check_variables
		end
	}
  end

  rule variable_args
  	"*" i:identifier
  end

  #Matches a unary operation, which requires a symbol to be
  #immediately followed by an expression.
  rule unary_operation
	op:operator !space rhs:unary_rhs_expression {
		def brat(res_var = nil)  
			next_temp
			rhs.brat <<
			"local #@result = #{rhs.result}\n" <<
			call_method(@result, @result, op.brat, "", 0) << "\n"
		end
	}
  end

  #Matches binary operations.
  rule binary_operation
	lhs:binary_operation_chain rhs:expression
	 {
		def brat(res_var = nil)
			next_temp
			final_result = @result
			output = "local #{final_result} \n do\n" <<
				lhs.brat <<
				rhs.brat
			@result = rhs.result
			in_stack = lhs.stack
			in_stack << @result
			out_stack = []
			op_stack = []
			res_stack = []
			val = true
			in_stack.each do |e|
				if val
					out_stack.push e
					val = false
				else
					prec = precedence(e)
					while op_stack.length > 0 && prec <= precedence(op_stack.last) do
						out_stack.push op_stack.pop
					end
					op_stack.push e
					val = true
				end
			end

			while not op_stack.empty?
				out_stack.push op_stack.pop
			end

			out_stack.each do |e|
				if e[0,5] == "_temp" || e.to_i.to_s == e
					res_stack.push e
				else
					r = res_stack.pop
					l = res_stack.pop
					next_temp
					output << "local #@result\n" << call_method(@result, l, e, r, 1) << "\n"
					res_stack.push @result
				end
			end
	
			output << "#{final_result} = #{res_stack.pop} \nend\n"
			@result = final_result
			output
		end
	}
  end

  #Matches several binary operations
  rule binary_operation_chain
	(lhs:binary_lhs_expression ~space op:operator ~space)+ {
		attr_reader :stack
		def brat(res_var = nil)	
			@stack = []
			output = ""
			elements.each do |e|
				output << e.lhs.brat << "\n"
				@stack << e.lhs.result
				@stack << e.op.brat
			end
			output
		end
	}
  end

  #Matches method calls which must have parentheses or no arguments
  rule method_with_parens
  	lhs:method_chain i:(identifier / operator) a:simple_arg_list {
		def brat(res_var = nil)
			output = lhs.brat res_var
			if res_var
				@result = res_var
			else
				@result = lhs.result
			end

			output << "\n" <<
			a.brat << "\n" <<
			call_method(@result, lhs.result, i.brat, a.list, a.length) << ";"
		end
	}
	/
  	lhs:method_chain i:(identifier / operator) &space {
		def brat(res_var = nil)
			output = lhs.brat res_var
			if res_var
				@result = res_var
			else
				@result = lhs.result
			end
	
			output <<
			call_method(@result, lhs.result, i.brat, "", 0)
		end
	}
	/
	i:identifier a:simple_arg_list {
		def brat(res_var = nil)
			next_temp
			a.brat <<
			invoke(@result, i.brat, a.list, a.length)
		end

		def check_variables
			id = i.brat
			unless var_exist? id
				var = var_exist? id, true
				if var
					var_add id, var
				end
			end

			a.check_variables
		end
	}
	/
	i:identifier ~(&space) {
		def brat(res_var = nil)
			@result = res_var || next_temp
			get_value(@result, i.brat, "", 0)
		end

		def check_variables
			id = i.brat
			unless var_exist? id
				var = var_exist? id, true
				if var
					var_add id, var
				end
			end
		end

	}
  end

  #Matches method/function invocations
  rule method_invocation
  	lhs:method_chain i:(identifier / operator) a:arg_list {
		def brat(res_var = nil)
			next_temp
			lhs.brat << 
			a.brat <<
			call_method(@result, lhs.result, i.brat, a.list, a.length) << "\n"
		end

		def no_result_brat
			self.brat
			#next_temp
			#"var #@result = {#{lhs.brat}}" << 
			#a.brat <<
			#call_method(@result, i.brat, a.list, a.length) 
		end

	}
	/
	m:identifier a:arg_list {
		def brat(res_var = nil)
			name = m.brat
			next_temp
			"local #@result\n" <<
				a.brat << 
				get_value(@result, name, a.list, a.length)
		end

		def no_result_brat
			self.brat
			#name = m.brat
			#a.brat <<
			#get_value_clean(name, a.list, a.length) << ";"
		end

		def check_variables
			id = m.brat
			unless var_exist? id
				var = var_exist? id, true
				if var
					var_add id, var
				end
			end

			a.check_variables
		end
	}
	/
	m:paren_exp a:arg_list {
		def brat(res_var = nil)
			m.brat(res_var) << "\n" <<
			a.brat << "\n" <<
			invoke(m.result, m.result, a.list, a.length)
		end
	}
	/
	f:function_definition !space a:simple_arg_list {
		def brat(res_var = nil)
			f.brat(res_var) << "\n" <<
			a.brat << "\n" <<
			invoke(f.result, f.result, a.list, a.length)
		end
	}

  end

  #Matches a method chain, up to the last "."
  rule method_chain
 	(e:method_lhs ".")+ {
		def brat(res_var = nil)
			output = elements.first.e.brat
			@result = elements.first.e.result
			meth = args = nil
			elements[1..-1].each do |elem|
				meth = elem.e.identifier.brat
				args = elem.e.arg_list
				output << args.brat
				output << call_method(@result, @result, meth, args.list, args.length) << "\n"
				if not elem.e.a.elements.empty?
					elem.e.a.elements.each do |ele|
						output << ele.inner_arg_list.brat
						output << "#@result = #{@result}.__get(#{ele.inner_arg_list.list});"
					end
				end
			end
			output
		end

		def check_variables
			elements.each do |e|
				e.check_variables
			end
		end
	}
  end

  #Matches expressions which can be the targets of method calls
  rule method_lhs
  	identifier !space arg_list a:("[" inner_arg_list "]")* {
		def brat(res_var = nil)
			next_temp
			output = arg_list.brat
			name = identifier.brat
			temp = var_exist? name

			output <<
			"local #@result\n" <<
			if temp
				<<-LUA
				local _t = type(#{temp});
				if _t == "table" or _t == "number" then
					#@result = #{temp}
				elseif _t == "function" then 
					#{invoke(@result, temp, arg_list.list, arg_list.length)}
				elseif #{temp} == nil then
					 error(exception.null_error("#{nice_id name}", "cannot call method on it"))
				else
					error(exception.method_error("this", "#{nice_id name}"))
				end
				LUA
			else
				<<-LUA
				if _self["#{name}"] ~= nil then
					#{call_method(@result, "_self", name, arg_list.list, arg_list.length)}
				elseif #{name} ~= nil then
					#@result = #{name};
				else
					error(exception.method_error("this", "#{nice_id name}"))
				end
				LUA
			end

			if not a.elements.empty?
				a.elements.each do |elem|
					output << elem.inner_arg_list.brat
					output << "#@result = #@result:get(#{elem.inner_arg_list.list});"
				end
			end
			output
		end

		def check_variables
			id = identifier.brat

			unless var_exist? id
				var = var_exist? id, true
				if var
					var_add id, var
				end
			end
		
			arg_list.check_variables			

			a.elements.each do |e|
				e.inner_arg_list.check_variables
			end
		end
	}
	/
	a:array a_rest:("[" space? inner_arg_list space? "]")+ {
		def brat(res_var = nil)
			next_temp
			output = a.brat << "\n" <<
			"#@result = #{a.result}"

			a_rest.elements.each do |elem|
				output << elem.inner_arg_list.brat
				output << "#@result = #{@result}:get(#{elem.inner_arg_list.list})\n"
			end
			output
		end

		def check_variables
			a.check_variables
			a_rest.elements.each do |e|
				e.inner_arg_list.check_variables
			end
		end
	}
	/
	f:function_definition !space a:simple_arg_list {
		def brat(res_var = nil)
			
			output = f.brat(res_var) << "\n" <<
			a.brat << "\n"
			@result = res_var || f.result
			output << invoke(@result, f.result, a.list, a.length)
		end
	}
	/
	f:function_definition &(".") {
		def brat(res_var = nil)
			"@brat.base_function.new({#{f.brat}})"
		end
	}
	/
	method_target_expression {
		def brat(res_var = nil)
			super
		end
	}
  end

  #Matches the "don't execute this" operator ("->") which just returns the method
  #instead of executing/calling it.
  rule method_access
  	"->" m:(identifier / operator) {
		def brat(res_var = nil)
			name = m.brat
			temp = var_exist? name
			if temp
				@result = temp
				""
			else	
				next_temp
				<<-LUA
				if #{name} == nil then
					local #@result = _self["#{name}"]
					if #@result == nil then
						error(exception.null_error("#{nice_id name}", "access it"))
					end
				else
					#@result = #{name}
				end
				LUA
			end
		end

		def check_variables
			id = m.brat

			unless var_exist? id
				var = var_exist? id, true
				if var
					var_add id, var
				end
			end
		end
	}
	/
  	o:method_invocation "->" m:(identifier / operator) {
		def brat(res_var = nil)
			name = m.brat
			output = o.brat
			@result = o.result
			output << <<-LUA
				#@result = #@result["#{name}"]
				if #@result == nil then
					error(exception.method_error("#{nice_id o.text_value}", "#{nice_id name}"))
				end
			LUA
		end
	}
  end

  #Matches an argument list, including no arguments at all
  rule arg_list
	'(' ~(space?) inner_arg_list ~(space?) ')' {
		def brat(res_var = nil)
			inner_arg_list.brat
		end

		def length
			inner_arg_list.length
		end

		def list
			inner_arg_list.list
		end
	}
	/
	'(' empty_list ')' {
		def brat(res_var = nil)
			""
		end

		def length
			0
		end

		def list
			""
		end
	}
	/
  	space inner_arg_list {
		def brat(res_var = nil)
			inner_arg_list.brat
		end

		def length
			inner_arg_list.length
		end

		def list
			inner_arg_list.list
		end

	}
	/
	![(] ~(&(space?)) {
		def brat(res_var = nil)
			""
		end

		def length
			0
		end

		def list
			""
		end

		def nothing?
			true
		end
	}
  end

  #Matches an argument list which must be in parentheses, or no arguments at all
  rule simple_arg_list
	'(' ~(space?) inner_arg_list ~(space?) ')' {
		def brat(res_var = nil)
			inner_arg_list.brat
		end

		def length
			inner_arg_list.length
		end

		def list
			inner_arg_list.list
		end
	}
	/
	'(' empty_list ')' {
		def brat(res_var = nil)
			""
		end

		def length
			0
		end

		def list
			""
		end
	}
  end

  #Matches the inside of the argument list
  rule inner_arg_list
  	e:arg_first o:arg_next* {
		attr_reader :length, :list
		def brat(res_var = nil)
			output = ""
			args = []
			named_args = []

			output << e.brat << "\n"

			if e.respond_to? :named_argument?
				named_args << e
			else
				args << e.result
			end

			o.elements.each do |elem|
				if elem.respond_to? :brat
					output << elem.arg_first.brat << "\n"

					if elem.arg_first.respond_to? :named_argument?
						named_args << elem.arg_first
					else
						args << elem.arg_first.result
					end
				end
			end

			unless named_args.empty?
				next_temp
				args << @result
				output << "local #@result = {}\n"
				named_args.map do |e|
					output << "#@result[#{e.key}] = #{e.value}\n"
				end
				output << "#@result = hash:new(#@result)\n"
			end

			@list = args.join(',')
			@length = args.length
			output
		end

		def check_variables
			e.check_variables
			o.elements.each do |elem|
				elem.arg_first.check_variables
			end
		end
	}
  end

  #Matches a single argument
  rule arg_first
	named_argument / expression
  end

  #Matches the rest of the arguments
  rule arg_next
  	~((space / eol_not_semicolon)*) "," ~((space / eol_not_semicolon)*) arg_first {
		def brat(res_var = nil)
		end
	}
	/
	~((space / eol_not_semicolon)*) arg_first:function_definition {
		def brat(res_var = nil)
		end
	} 
	/
	~((space / eol_not_semicolon)*) arg_first:named_argument {
               def brat(res_var = nil)
               end
	}
	/
	~(space?) arg_first:expression {
		def brat(res_var = nil)
		end
	}
  end
 
  #Matches a 'named' argument
  rule named_argument
	i:((identifier / operator) (identifier / operator / number)*) ":" spaceorbreak e:expression {
		attr_reader :key, :value

		def brat(res_var = nil)
			@key = "string:new(\"#{i.text_value}\")"
			output = e.brat
			@value = e.result
			output
		end

		def named_argument?
			true
		end
	}
	/
  	i:expression space? ":" space spaceorbreak e:expression {
		attr_reader :key, :value

		def brat(res_var = nil)
			output = i.brat << "\n" << e.brat
			@key = i.result
			@value = e.result
			output
		end

		def named_argument?
			true
		end
	}
  end

  #Matches allowable operators and converts them to mangled method names
  rule operator
	~(!("->" !operator) !("=" !(operator / "="))) ("!=" / ">=" / "<=" / [!?\-*+^@~/\\><$_%\=] / "||" / "|" / "&&" / "&")+ {
		def brat(res_var = nil)
			escape_operator(text_value)
		end
	}
  end

  #Matches nothing or spaces
  rule empty_list
  	~(space?)
  end

  #Matches end-of-lines, which can be \n, ;, or \r\n
  rule eol
	("\n" / ";" / "\r\n")+ {
		def brat(res_var = nil)
			"\n"
		end
	}
  end

  rule eol_not_semicolon
	("\n" / "\r\n")+ {
		def brat(res_var = nil)
			"\n"
		end
	}
  end

  #Matches spaces or tabs
  rule space
     (" " / "\t")+ {
		def brat(res_var = nil)
			text_value
		end
	}
  end
  
  #Matches the end of the file
  rule eof
  	~((eol / space)? !.)
  end

  #Matches the end of a function
  rule eob
  	~(space? &"}" space?)
  end

  #Matches spaces, eols, or nothing
  rule spaceorbreak
	space? eol? space?
  end
end
