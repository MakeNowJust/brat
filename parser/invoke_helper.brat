h = object.new

h.callable? = { name |
  "_type(#{name}) == \"function\" or (_type(#{name}) == \"table\" and _rawget(#{name}, \"__call_thing\"))"
}

h.get_action = { res_var |
  true? res_var == '_return_'
    { "return " }
    { true? res_var
      { "#{res_var} = " }
      { "_dummy_ = " }
    }
}

h.invoke = { node, target, invoke_meth, var |
  res = set_result var
  w = my
  target_var = null
  true? target
    {
       res.out << target.out; target_var = target.var
    }

  args = (node.args || {[]}).map { n | w.process n }
  avars = args.map({ a | a.var })
  res.out << args.map({ a | a.out }).join("\n")
  res.out << invoke_meth target_var, node.method, avars, res.var
  avars.each { v | w.env.unset v }
  res
}

h.invoke_local = { t_, name, args, res_var |
  args = (["_self"] + args).join(", ")
  temp = my.env[name]

  action = get_action res_var
  call_it = "#{action} #{temp}(#{args})\n"

  nonmethod_error = "_error(exception:new(\"Tried to invoke non-method: '#{name}' (\" .. object.__type(#{temp}) .. \")\"))"

  t = my.env.get_type temp

  true? t
   {
    true? t == :function
      { call_it }
      {
        nonmethod_error
      }
   }
   {
    "
    if #{callable? temp} then
      #{call_it}
    elseif #{temp} then
      #{action} #{temp}(#{args})
    else
      #{nonmethod_error}
    end
    "
  }
}

h.invoke_self = { t_, name, args, res_var |
  args_array = (["_self"] + args).join(", ")
  action = get_action res_var
  call_it = "#{action} #{name}(#{args_array})\n"

  "
  if #{name} then
    #{call_it}
  else
    #{invoke_method '_self', name, args, res_var}
  end
  "
}

h.invoke_number_method = { target, name, args, res_var |
  "
    local _n = number:new(#{target})
    #{invoke_method_helper '_n', name, args, res_var}"
}

h.invoke_method = { target, name, args, res_var |
  true? (target.number? || { h.number? target })
  { invoke_number_method target, name, args, res_var }
  {
    "if _type(#{target}) == 'number' then
      #{target} = number:new(#{target})
    end
    #{invoke_method_helper target, name, args, res_var}"
  }

}

h.invoke_index_get = { target, n_, args, res_var |
  args_array = (['_self'] + args).join(", ")
  action = get_action res_var
  "
  if #{callable? target} then
    #{action} #{target}(#{args_array})
  else
    _error(exception:new(\"Tried to invoke non-method: '#{target}' (\" .. object.__type(#{target}) .. \")\"))
  end
  "
}

h.invoke_function = { target, n_, args, res_var |
  args_array = (['_self'] + args).join(", ")
  action = get_action res_var

  "
  #{action} #{target}(#{args_array})
  "
}

h.invoke_method_helper = { target, name, args, res_var |
  action = get_action res_var
  true? args.empty?
  {
     "
      local _m = #{target}.#{name}
      if #{callable? '_m'} then
        #{action} _m(#{target})
      elseif _m ~= nil then
        #{action} _m
      elseif #{target}.no_undermethod then
        #{action} #{target}:no_undermethod('#{unescape_identifier name}')
      else
        _error(exception:method_error(#{target}, '#{name}'))
      end
    "
  }
  {
    arg_list = ([target] + args).join(', ')

    "
      local _m = #{target}.#{name}
      if #{callable? '_m'} then
        #{action} _m(#{arg_list})
      elseif _m ~= nil then
          _error(exception:argument_error('function', 0, #{args.length - 1 }))
      elseif #{target}.no_undermethod then
        #{action} #{target}:no_undermethod('#{unescape_identifier name}', #{args.join(', ')})
      else
        _error(exception:method_error(#{target}, '#{name}'))
      end
    "
  }
}

native_ops = ["_percent", "_plus", "_minus", "_forward", "_star", "_up"]
compare_ops = ["_less", "_greater", "_equal_equal", "_less_equal", "_greater_equal"]

h.invoke_numbers = { lhs, op, rhs, res_var |
  action = get_action res_var

  invoked = invoke_method lhs, op, [rhs], res_var

  true? native_ops.include?(op)
  {
    "
    if number._unchanged('op') then
      #{action} #{lhs} #{unescape_op op} #{rhs}
    else
      #{invoked}
    end
    "
  }
  {
    true? compare_ops.include?(op)
    {
      "
      if number._unchanged('op') then
        if #{lhs} #{unescape_op op} #{rhs} then
          #{action} object.__true
        else
          #{action} object.__false
        end
      else
        #{invoked}
      end
      "
    }
    {
      invoked
    }
  }
}

h.get_a_value = { node, var = null |
  res = set_result var
  res.out << get_local_value(node.value, res.var)
  res
}

h.get_local_value = { name, res_var |
  temp = my.env[name]

  action = get_action res_var

  call_it = "#{action} #{temp}(_self)\n"

  t = my.env.get_type temp

  true? t
   {
    true? t == :function
      { call_it }
      {
        true? res_var
          { my.env.set_type res_var, t }

        "#{action} #{temp}\n"
      }
   }
   {
    "
    if #{callable? temp} then
      #{call_it}
    elseif #{temp} then
      #{action} #{temp}
    else
      _error(exception:name_error(\"#{name}\"))
    end
    "
  }
}


h.get_value = { name, res_var |
  true? res_var == '_return_'
    { res_var = null }

  action = true? res_var
            { "#{res_var} =" }
            { "return" }

  call_it = "#{action} #{name}(_self)\n"

  "
   local _m
   if #{name} then
     _m = #{name}
   else
     _m = _self[\"#{name}\"]
   end
   if #{callable? '_m'} then
     #{action} _m(_self)
   elseif _m then
     #{action} _m
   else
     _error(exception:name_error(\"#{name}\"))
   end
  "
}

h.get_method_local = { name, res_var |
  action = get_action res_var
  temp = my.env[name]

  "
  if #{temp} then
    #{action} #{temp}
  else
    _error(exception:null_error(\"#{name}\", \"access it\"))
  end
  "
}

h.get_method_self = { name, res_var |
  action = get_action res_var

  "
  if _self[\"#{name}\"] then
    #{action} _self[\"#{name}\"]
  else
    _error(exception:null_error(\"#{name}\", \"access it\"))
  end
  "
}

h.get_method = { target, name, res_var |
  action = get_action res_var

  "
  if #{target}[\"#{name}\"] then
    #{action} #{target}[\"#{name}\"]
  else
    _error(exception:method_error(\"#{target}\", \"#{name|}\"))
  end
  "
}

export h, :invoke_helper
